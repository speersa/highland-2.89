//
// File generated by /t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64//bin/rootcint at Thu Apr 20 02:08:55 2023

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME dIhomedIt2kdIaspeersdIHighland_InstallsdIHighLAND_2dO89dIpsycheEventModel_3dO47dILinuxmICentOS_7mIgcc_4dO8mIx86_64dIdictdIG_BaseDataClasses
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "G_BaseDataClasses.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TInterpreter.h"
#include "TVirtualMutex.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// Direct notice to TROOT of the dictionary's loading.
namespace {
   static struct DictInit {
      DictInit() {
         ROOT::RegisterModule();
      }
   } __TheDictionaryInitializer;
}

// START OF SHADOWS

namespace ROOTShadow {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaTrueParticleB AnaTrueParticleB;
      #else
      class AnaTrueParticleB  :  public ::AnaTrueObjectC {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaTrueParticleB() throw() {};
         int PDG; //
         int PrimaryID; //
         int ParentID; //
         int ParentPDG; //
         int GParentID; //
         int GParentPDG; //
         float Position[4]; //
         float PositionEnd[4]; //
         float Direction[3]; //
         float Momentum; //
         float Charge; //
         int VertexID; //
         ::AnaTrueVertexB* TrueVertex; //!
         ::AnaDetCrossingB** DetCrossings; //!
         int nDetCrossings; //!
         vector< ::AnaDetCrossingB* > DetCrossingsVect; //
         bool IsTruePrimaryPi0DecayPhoton; //
         bool IsTruePrimaryPi0DecayPhotonChild; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaDetCrossingB AnaDetCrossingB;
      #else
      class AnaDetCrossingB  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaDetCrossingB() throw() {};
         float EntrancePosition[4]; //
         float ExitPosition[4]; //
         float EntranceMomentum[3]; //
         float ExitMomentum[3]; //
         bool InActive; //
         unsigned long Detector; //
         bool ExitOK; //
         bool EntranceOK; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaTrueVertexB AnaTrueVertexB;
      #else
      class AnaTrueVertexB  :  public ::AnaTrueObjectC {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaTrueVertexB() throw() {};
         int NuPDG; //
         float NuEnergy; //
         float Position[4]; //
         int Bunch; //
         ::AnaTrueParticleB** TrueParticles; //!
         int nTrueParticles; //!
         vector< Int_t > TrueParticlesIDsVect; //
         unsigned long Detector; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaToF AnaToF;
      #else
      class AnaToF  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::AnaToF::TimeStatusFlag TimeStatusFlag;
         #else
         enum TimeStatusFlag  {
         };
         #endif

         float FGD1_FGD2; //
         int Flag_FGD1_FGD2; //
         float P0D_FGD1; //
         int Flag_P0D_FGD1; //
         float DSECal_FGD1; //
         int Flag_DSECal_FGD1; //
         float ECal_FGD1; //
         int Flag_ECal_FGD1; //
         float ECal_FGD2; //
         int Flag_ECal_FGD2; //
         float DSECal_FGD2; //
         int Flag_DSECal_FGD2; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaParticleB AnaParticleB;
      #else
      class AnaParticleB  :  public ::AnaRecObjectC {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaParticleB() throw() {};
         int NHits; //
         int NNodes; //
         float DirectionStart[3]; //
         float DirectionEnd[3]; //
         float PositionStart[4]; //
         float PositionEnd[4]; //
         :: AnaParticleB* Original; //!
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaParticleMomE AnaParticleMomE;
      #else
      class AnaParticleMomE  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaParticleMomE() throw() {};
         float Charge; //
         float Momentum; //
         float MomentumEnd; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaParticleMomB AnaParticleMomB;
      #else
      class AnaParticleMomB  :  public ::AnaParticleB,  public ::AnaParticleMomE {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaParticleMomB() throw() {};
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaTPCParticleB AnaTPCParticleB;
      #else
      class AnaTPCParticleB  :  public ::AnaParticleMomB {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaTPCParticleB() throw() {};
         float MomentumError; //
         float RefitMomentum; //
         float EFieldRefitMomentum; //
         float dEdxMeas; //
         float dEdxexpMuon; //
         float dEdxexpEle; //
         float dEdxexpPion; //
         float dEdxexpProton; //
         float dEdxSigmaMuon; //
         float dEdxSigmaEle; //
         float dEdxSigmaPion; //
         float dEdxSigmaProton; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaFGDParticleB AnaFGDParticleB;
      #else
      class AnaFGDParticleB  :  public ::AnaParticleB {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaFGDParticleB() throw() {};
         float X; //
         float E; //
         float Pullmu; //
         float Pullp; //
         float Pullpi; //
         float Pullno; //
         float Pulle; //
         int Containment; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaECALParticleB AnaECALParticleB;
      #else
      class AnaECALParticleB  :  public ::AnaParticleB {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaECALParticleB() throw() {};
         int Clustering3DSeedType; //
         int ClusteringAdded3DClusterHits; //
         float PIDQuality; //
         float PIDMipEm; //
         float PIDMipPion; //
         float PIDEmHip; //
         float Length; //
         float EMEnergy; //
         float EDeposit; //
         int IsShowerLike; //
         float AvgTime; //
         int MostUpStreamLayerHit; //
         float ShowerPosition[3]; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaSMRDParticleB AnaSMRDParticleB;
      #else
      class AnaSMRDParticleB  :  public ::AnaParticleB {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaSMRDParticleB() throw() {};
         float AvgTime; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaP0DParticleB AnaP0DParticleB;
      #else
      class AnaP0DParticleB  :  public ::AnaParticleB {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaP0DParticleB() throw() {};
         float Length; //
         float ELoss; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaTrackerTrackB AnaTrackerTrackB;
      #else
      class AnaTrackerTrackB  :  public ::AnaParticleMomB {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaTrackerTrackB() throw() {};
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaRecTrueMatchB AnaRecTrueMatchB;
      #else
      class AnaRecTrueMatchB  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaRecTrueMatchB() throw() {};
         float Cleanliness; //
         float Completeness; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaTrackB AnaTrackB;
      #else
      class AnaTrackB  :  public ::AnaParticleMomB {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaTrackB() throw() {};
         bool IsFlipped; //
         int Index; //
         float RangeMomentumMuon; //
         float RangeMomentumProton; //
         float RangeMomentumPion; //
         float MomentumFlip; //
         int TPCQualityCut; //
         ::AnaToF ToF; //
         ::AnaTPCParticleB* TPCSegments[3]; //!
         int nTPCSegments; //!
         ::AnaFGDParticleB* FGDSegments[2]; //!
         int nFGDSegments; //!
         ::AnaECALParticleB* ECALSegments[3]; //!
         int nECALSegments; //!
         ::AnaSMRDParticleB* SMRDSegments[4]; //!
         int nSMRDSegments; //!
         ::AnaP0DParticleB* P0DSegments[1]; //!
         int nP0DSegments; //!
         vector< ::AnaTPCParticleB* > TPCSegmentsVect; //
         vector< ::AnaFGDParticleB* > FGDSegmentsVect; //
         vector< ::AnaECALParticleB* > ECALSegmentsVect; //
         vector< ::AnaSMRDParticleB* > SMRDSegmentsVect; //
         vector< ::AnaP0DParticleB* > P0DSegmentsVect; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaVertexB AnaVertexB;
      #else
      class AnaVertexB  :  public ::AnaRecObjectC {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaVertexB() throw() {};
         int Bunch; //
         int PrimaryIndex; //
         float Position[4]; //
         ::AnaParticleB** Particles; //!
         int nParticles; //!
         vector< Int_t > ParticlesIDsVect; //
         ::AnaTrueVertexB* TrueVertex; //!
         vector< pair< ::AnaTrueVertexB*, ::AnaRecTrueMatchB >  > TrueVerticesMatch; //!
         :: AnaVertexB* Original; //!
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaBeamB AnaBeamB;
      #else
      class AnaBeamB  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaBeamB() throw() {};
         int GoodSpill; //
         double POTSincePreviousSavedSpill; //
         int SpillsSincePreviousSavedSpill; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaDataQualityB AnaDataQualityB;
      #else
      class AnaDataQualityB  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaDataQualityB() throw() {};
         bool GoodDaq; //
         bool GoodTimeDaq; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaDelayedClustersB AnaDelayedClustersB;
      #else
      class AnaDelayedClustersB  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaDelayedClustersB() throw() {};
         float MinTime; //Minimum time of a hit in the cluster
         float MaxTime; //Maximum time of a hit in the cluster
         int NHits; //Number of hits in the cluster
         float RawChargeSum; //Sum of the RawCharge of all hits
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaBunchB AnaBunchB;
      #else
      class AnaBunchB  :  public ::AnaBunchC {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaBunchB() throw() {};
         vector< ::AnaVertexB* > Vertices; //
         vector< ::AnaParticleB* > Particles; //
         ::AnaDelayedClustersB** DelayedClusters; //! 
         int nDelayedClusters; //! 
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaFgdTimeBinB AnaFgdTimeBinB;
      #else
      class AnaFgdTimeBinB  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaFgdTimeBinB() throw() {};
         float MinTime; //
         int NHits[2]; //
         float RawChargeSum[2]; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaEventInfoB AnaEventInfoB;
      #else
      class AnaEventInfoB  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaEventInfoB() throw() {};
         int Run; //
         int SubRun; //
         int Event; //
         bool IsMC; //
         bool IsSand; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaSpillB AnaSpillB;
      #else
      class AnaSpillB  :  public ::AnaSpillC {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaSpillB() throw() {};
         unsigned int GeomID; //
         ::AnaEventInfoB* EventInfo; //
         ::AnaDataQualityB* DataQuality; //
         ::AnaBeamB* Beam; //
         unsigned int NTotalTrueVertices; //
         unsigned int NTotalTrueParticles; //
         vector< ::AnaTrueVertexB* > TrueVertices; //
         vector< ::AnaTrueParticleB* > TrueParticles; //
         ::AnaBunchB* OutOfBunch; //
         vector< ::AnaFgdTimeBinB* > FgdTimeBins; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::AnaEventB AnaEventB;
      #else
      class AnaEventB  :  public ::AnaEventC {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~AnaEventB() throw() {};
         ::AnaEventInfoB EventInfo; //
         ::AnaDataQualityB* DataQuality; //
         ::AnaBeamB* Beam; //
         int Bunch; //
         ::AnaParticleB** Particles; //
         int nParticles; //
         ::AnaVertexB** Vertices; //
         int nVertices; //
         ::AnaFgdTimeBinB** FgdTimeBins; //
         int nFgdTimeBins; //
         ::AnaDelayedClustersB** DelayedClusters; //! 
         int nDelayedClusters; //! 
         ::AnaTrueParticleB** TrueParticles; //
         int nTrueParticles; //
         ::AnaTrueVertexB** TrueVertices; //
         int nTrueVertices; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOTShadow
// END OF SHADOWS

namespace ROOTDict {
   void AnaTrueParticleB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaTrueParticleB_Dictionary();
   static void *new_AnaTrueParticleB(void *p = 0);
   static void *newArray_AnaTrueParticleB(Long_t size, void *p);
   static void delete_AnaTrueParticleB(void *p);
   static void deleteArray_AnaTrueParticleB(void *p);
   static void destruct_AnaTrueParticleB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaTrueParticleB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaTrueParticleB) == sizeof( ::ROOTShadow::Shadow::AnaTrueParticleB));
      ::AnaTrueParticleB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaTrueParticleB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaTrueParticleB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 148,
                  typeid(::AnaTrueParticleB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaTrueParticleB_ShowMembers, &AnaTrueParticleB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaTrueParticleB) );
      instance.SetNew(&new_AnaTrueParticleB);
      instance.SetNewArray(&newArray_AnaTrueParticleB);
      instance.SetDelete(&delete_AnaTrueParticleB);
      instance.SetDeleteArray(&deleteArray_AnaTrueParticleB);
      instance.SetDestructor(&destruct_AnaTrueParticleB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaTrueParticleB*)
   {
      return GenerateInitInstanceLocal((::AnaTrueParticleB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaTrueParticleB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaTrueParticleB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrueParticleB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaDetCrossingB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaDetCrossingB_Dictionary();
   static void *new_AnaDetCrossingB(void *p = 0);
   static void *newArray_AnaDetCrossingB(Long_t size, void *p);
   static void delete_AnaDetCrossingB(void *p);
   static void deleteArray_AnaDetCrossingB(void *p);
   static void destruct_AnaDetCrossingB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaDetCrossingB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaDetCrossingB) == sizeof( ::ROOTShadow::Shadow::AnaDetCrossingB));
      ::AnaDetCrossingB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaDetCrossingB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaDetCrossingB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 52,
                  typeid(::AnaDetCrossingB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaDetCrossingB_ShowMembers, &AnaDetCrossingB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaDetCrossingB) );
      instance.SetNew(&new_AnaDetCrossingB);
      instance.SetNewArray(&newArray_AnaDetCrossingB);
      instance.SetDelete(&delete_AnaDetCrossingB);
      instance.SetDeleteArray(&deleteArray_AnaDetCrossingB);
      instance.SetDestructor(&destruct_AnaDetCrossingB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaDetCrossingB*)
   {
      return GenerateInitInstanceLocal((::AnaDetCrossingB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaDetCrossingB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaDetCrossingB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaDetCrossingB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaTrueVertexB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaTrueVertexB_Dictionary();
   static void *new_AnaTrueVertexB(void *p = 0);
   static void *newArray_AnaTrueVertexB(Long_t size, void *p);
   static void delete_AnaTrueVertexB(void *p);
   static void deleteArray_AnaTrueVertexB(void *p);
   static void destruct_AnaTrueVertexB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaTrueVertexB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaTrueVertexB) == sizeof( ::ROOTShadow::Shadow::AnaTrueVertexB));
      ::AnaTrueVertexB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaTrueVertexB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaTrueVertexB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 97,
                  typeid(::AnaTrueVertexB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaTrueVertexB_ShowMembers, &AnaTrueVertexB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaTrueVertexB) );
      instance.SetNew(&new_AnaTrueVertexB);
      instance.SetNewArray(&newArray_AnaTrueVertexB);
      instance.SetDelete(&delete_AnaTrueVertexB);
      instance.SetDeleteArray(&deleteArray_AnaTrueVertexB);
      instance.SetDestructor(&destruct_AnaTrueVertexB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaTrueVertexB*)
   {
      return GenerateInitInstanceLocal((::AnaTrueVertexB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaTrueVertexB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaTrueVertexB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrueVertexB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaToF_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaToF_Dictionary();
   static void *new_AnaToF(void *p = 0);
   static void *newArray_AnaToF(Long_t size, void *p);
   static void delete_AnaToF(void *p);
   static void deleteArray_AnaToF(void *p);
   static void destruct_AnaToF(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaToF*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaToF) == sizeof( ::ROOTShadow::Shadow::AnaToF));
      ::AnaToF *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaToF),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaToF", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 229,
                  typeid(::AnaToF), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaToF_ShowMembers, &AnaToF_Dictionary, isa_proxy, 4,
                  sizeof(::AnaToF) );
      instance.SetNew(&new_AnaToF);
      instance.SetNewArray(&newArray_AnaToF);
      instance.SetDelete(&delete_AnaToF);
      instance.SetDeleteArray(&deleteArray_AnaToF);
      instance.SetDestructor(&destruct_AnaToF);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaToF*)
   {
      return GenerateInitInstanceLocal((::AnaToF*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaToF*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaToF_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaToF*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaParticleB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaParticleB_Dictionary();
   static void *new_AnaParticleB(void *p = 0);
   static void *newArray_AnaParticleB(Long_t size, void *p);
   static void delete_AnaParticleB(void *p);
   static void deleteArray_AnaParticleB(void *p);
   static void destruct_AnaParticleB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaParticleB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaParticleB) == sizeof( ::ROOTShadow::Shadow::AnaParticleB));
      ::AnaParticleB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaParticleB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaParticleB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 284,
                  typeid(::AnaParticleB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaParticleB_ShowMembers, &AnaParticleB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaParticleB) );
      instance.SetNew(&new_AnaParticleB);
      instance.SetNewArray(&newArray_AnaParticleB);
      instance.SetDelete(&delete_AnaParticleB);
      instance.SetDeleteArray(&deleteArray_AnaParticleB);
      instance.SetDestructor(&destruct_AnaParticleB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaParticleB*)
   {
      return GenerateInitInstanceLocal((::AnaParticleB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaParticleB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaParticleB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaParticleB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaParticleMomE_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaParticleMomE_Dictionary();
   static void *new_AnaParticleMomE(void *p = 0);
   static void *newArray_AnaParticleMomE(Long_t size, void *p);
   static void delete_AnaParticleMomE(void *p);
   static void deleteArray_AnaParticleMomE(void *p);
   static void destruct_AnaParticleMomE(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaParticleMomE*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaParticleMomE) == sizeof( ::ROOTShadow::Shadow::AnaParticleMomE));
      ::AnaParticleMomE *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaParticleMomE),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaParticleMomE", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 339,
                  typeid(::AnaParticleMomE), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaParticleMomE_ShowMembers, &AnaParticleMomE_Dictionary, isa_proxy, 4,
                  sizeof(::AnaParticleMomE) );
      instance.SetNew(&new_AnaParticleMomE);
      instance.SetNewArray(&newArray_AnaParticleMomE);
      instance.SetDelete(&delete_AnaParticleMomE);
      instance.SetDeleteArray(&deleteArray_AnaParticleMomE);
      instance.SetDestructor(&destruct_AnaParticleMomE);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaParticleMomE*)
   {
      return GenerateInitInstanceLocal((::AnaParticleMomE*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaParticleMomE*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaParticleMomE_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaParticleMomE*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaParticleMomB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaParticleMomB_Dictionary();
   static void *new_AnaParticleMomB(void *p = 0);
   static void *newArray_AnaParticleMomB(Long_t size, void *p);
   static void delete_AnaParticleMomB(void *p);
   static void deleteArray_AnaParticleMomB(void *p);
   static void destruct_AnaParticleMomB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaParticleMomB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaParticleMomB) == sizeof( ::ROOTShadow::Shadow::AnaParticleMomB));
      ::AnaParticleMomB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaParticleMomB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaParticleMomB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 367,
                  typeid(::AnaParticleMomB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaParticleMomB_ShowMembers, &AnaParticleMomB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaParticleMomB) );
      instance.SetNew(&new_AnaParticleMomB);
      instance.SetNewArray(&newArray_AnaParticleMomB);
      instance.SetDelete(&delete_AnaParticleMomB);
      instance.SetDeleteArray(&deleteArray_AnaParticleMomB);
      instance.SetDestructor(&destruct_AnaParticleMomB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaParticleMomB*)
   {
      return GenerateInitInstanceLocal((::AnaParticleMomB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaParticleMomB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaParticleMomB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaParticleMomB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaTPCParticleB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaTPCParticleB_Dictionary();
   static void *new_AnaTPCParticleB(void *p = 0);
   static void *newArray_AnaTPCParticleB(Long_t size, void *p);
   static void delete_AnaTPCParticleB(void *p);
   static void deleteArray_AnaTPCParticleB(void *p);
   static void destruct_AnaTPCParticleB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaTPCParticleB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaTPCParticleB) == sizeof( ::ROOTShadow::Shadow::AnaTPCParticleB));
      ::AnaTPCParticleB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaTPCParticleB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaTPCParticleB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 392,
                  typeid(::AnaTPCParticleB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaTPCParticleB_ShowMembers, &AnaTPCParticleB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaTPCParticleB) );
      instance.SetNew(&new_AnaTPCParticleB);
      instance.SetNewArray(&newArray_AnaTPCParticleB);
      instance.SetDelete(&delete_AnaTPCParticleB);
      instance.SetDeleteArray(&deleteArray_AnaTPCParticleB);
      instance.SetDestructor(&destruct_AnaTPCParticleB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaTPCParticleB*)
   {
      return GenerateInitInstanceLocal((::AnaTPCParticleB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaTPCParticleB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaTPCParticleB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTPCParticleB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaFGDParticleB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaFGDParticleB_Dictionary();
   static void *new_AnaFGDParticleB(void *p = 0);
   static void *newArray_AnaFGDParticleB(Long_t size, void *p);
   static void delete_AnaFGDParticleB(void *p);
   static void deleteArray_AnaFGDParticleB(void *p);
   static void destruct_AnaFGDParticleB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaFGDParticleB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaFGDParticleB) == sizeof( ::ROOTShadow::Shadow::AnaFGDParticleB));
      ::AnaFGDParticleB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaFGDParticleB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaFGDParticleB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 451,
                  typeid(::AnaFGDParticleB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaFGDParticleB_ShowMembers, &AnaFGDParticleB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaFGDParticleB) );
      instance.SetNew(&new_AnaFGDParticleB);
      instance.SetNewArray(&newArray_AnaFGDParticleB);
      instance.SetDelete(&delete_AnaFGDParticleB);
      instance.SetDeleteArray(&deleteArray_AnaFGDParticleB);
      instance.SetDestructor(&destruct_AnaFGDParticleB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaFGDParticleB*)
   {
      return GenerateInitInstanceLocal((::AnaFGDParticleB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaFGDParticleB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaFGDParticleB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaFGDParticleB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaECALParticleB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaECALParticleB_Dictionary();
   static void *new_AnaECALParticleB(void *p = 0);
   static void *newArray_AnaECALParticleB(Long_t size, void *p);
   static void delete_AnaECALParticleB(void *p);
   static void deleteArray_AnaECALParticleB(void *p);
   static void destruct_AnaECALParticleB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaECALParticleB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaECALParticleB) == sizeof( ::ROOTShadow::Shadow::AnaECALParticleB));
      ::AnaECALParticleB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaECALParticleB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaECALParticleB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 497,
                  typeid(::AnaECALParticleB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaECALParticleB_ShowMembers, &AnaECALParticleB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaECALParticleB) );
      instance.SetNew(&new_AnaECALParticleB);
      instance.SetNewArray(&newArray_AnaECALParticleB);
      instance.SetDelete(&delete_AnaECALParticleB);
      instance.SetDeleteArray(&deleteArray_AnaECALParticleB);
      instance.SetDestructor(&destruct_AnaECALParticleB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaECALParticleB*)
   {
      return GenerateInitInstanceLocal((::AnaECALParticleB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaECALParticleB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaECALParticleB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaECALParticleB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaSMRDParticleB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaSMRDParticleB_Dictionary();
   static void *new_AnaSMRDParticleB(void *p = 0);
   static void *newArray_AnaSMRDParticleB(Long_t size, void *p);
   static void delete_AnaSMRDParticleB(void *p);
   static void deleteArray_AnaSMRDParticleB(void *p);
   static void destruct_AnaSMRDParticleB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaSMRDParticleB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaSMRDParticleB) == sizeof( ::ROOTShadow::Shadow::AnaSMRDParticleB));
      ::AnaSMRDParticleB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaSMRDParticleB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaSMRDParticleB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 566,
                  typeid(::AnaSMRDParticleB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaSMRDParticleB_ShowMembers, &AnaSMRDParticleB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaSMRDParticleB) );
      instance.SetNew(&new_AnaSMRDParticleB);
      instance.SetNewArray(&newArray_AnaSMRDParticleB);
      instance.SetDelete(&delete_AnaSMRDParticleB);
      instance.SetDeleteArray(&deleteArray_AnaSMRDParticleB);
      instance.SetDestructor(&destruct_AnaSMRDParticleB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaSMRDParticleB*)
   {
      return GenerateInitInstanceLocal((::AnaSMRDParticleB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaSMRDParticleB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaSMRDParticleB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaSMRDParticleB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaP0DParticleB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaP0DParticleB_Dictionary();
   static void *new_AnaP0DParticleB(void *p = 0);
   static void *newArray_AnaP0DParticleB(Long_t size, void *p);
   static void delete_AnaP0DParticleB(void *p);
   static void deleteArray_AnaP0DParticleB(void *p);
   static void destruct_AnaP0DParticleB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaP0DParticleB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaP0DParticleB) == sizeof( ::ROOTShadow::Shadow::AnaP0DParticleB));
      ::AnaP0DParticleB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaP0DParticleB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaP0DParticleB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 590,
                  typeid(::AnaP0DParticleB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaP0DParticleB_ShowMembers, &AnaP0DParticleB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaP0DParticleB) );
      instance.SetNew(&new_AnaP0DParticleB);
      instance.SetNewArray(&newArray_AnaP0DParticleB);
      instance.SetDelete(&delete_AnaP0DParticleB);
      instance.SetDeleteArray(&deleteArray_AnaP0DParticleB);
      instance.SetDestructor(&destruct_AnaP0DParticleB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaP0DParticleB*)
   {
      return GenerateInitInstanceLocal((::AnaP0DParticleB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaP0DParticleB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaP0DParticleB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaP0DParticleB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaTrackerTrackB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaTrackerTrackB_Dictionary();
   static void *new_AnaTrackerTrackB(void *p = 0);
   static void *newArray_AnaTrackerTrackB(Long_t size, void *p);
   static void delete_AnaTrackerTrackB(void *p);
   static void deleteArray_AnaTrackerTrackB(void *p);
   static void destruct_AnaTrackerTrackB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaTrackerTrackB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaTrackerTrackB) == sizeof( ::ROOTShadow::Shadow::AnaTrackerTrackB));
      ::AnaTrackerTrackB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaTrackerTrackB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaTrackerTrackB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 614,
                  typeid(::AnaTrackerTrackB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaTrackerTrackB_ShowMembers, &AnaTrackerTrackB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaTrackerTrackB) );
      instance.SetNew(&new_AnaTrackerTrackB);
      instance.SetNewArray(&newArray_AnaTrackerTrackB);
      instance.SetDelete(&delete_AnaTrackerTrackB);
      instance.SetDeleteArray(&deleteArray_AnaTrackerTrackB);
      instance.SetDestructor(&destruct_AnaTrackerTrackB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaTrackerTrackB*)
   {
      return GenerateInitInstanceLocal((::AnaTrackerTrackB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaTrackerTrackB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaTrackerTrackB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrackerTrackB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaRecTrueMatchB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaRecTrueMatchB_Dictionary();
   static void *new_AnaRecTrueMatchB(void *p = 0);
   static void *newArray_AnaRecTrueMatchB(Long_t size, void *p);
   static void delete_AnaRecTrueMatchB(void *p);
   static void deleteArray_AnaRecTrueMatchB(void *p);
   static void destruct_AnaRecTrueMatchB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaRecTrueMatchB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaRecTrueMatchB) == sizeof( ::ROOTShadow::Shadow::AnaRecTrueMatchB));
      ::AnaRecTrueMatchB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaRecTrueMatchB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaRecTrueMatchB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 634,
                  typeid(::AnaRecTrueMatchB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaRecTrueMatchB_ShowMembers, &AnaRecTrueMatchB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaRecTrueMatchB) );
      instance.SetNew(&new_AnaRecTrueMatchB);
      instance.SetNewArray(&newArray_AnaRecTrueMatchB);
      instance.SetDelete(&delete_AnaRecTrueMatchB);
      instance.SetDeleteArray(&deleteArray_AnaRecTrueMatchB);
      instance.SetDestructor(&destruct_AnaRecTrueMatchB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaRecTrueMatchB*)
   {
      return GenerateInitInstanceLocal((::AnaRecTrueMatchB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaRecTrueMatchB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaRecTrueMatchB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaRecTrueMatchB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaTrackB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaTrackB_Dictionary();
   static void *new_AnaTrackB(void *p = 0);
   static void *newArray_AnaTrackB(Long_t size, void *p);
   static void delete_AnaTrackB(void *p);
   static void deleteArray_AnaTrackB(void *p);
   static void destruct_AnaTrackB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaTrackB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaTrackB) == sizeof( ::ROOTShadow::Shadow::AnaTrackB));
      ::AnaTrackB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaTrackB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaTrackB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 655,
                  typeid(::AnaTrackB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaTrackB_ShowMembers, &AnaTrackB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaTrackB) );
      instance.SetNew(&new_AnaTrackB);
      instance.SetNewArray(&newArray_AnaTrackB);
      instance.SetDelete(&delete_AnaTrackB);
      instance.SetDeleteArray(&deleteArray_AnaTrackB);
      instance.SetDestructor(&destruct_AnaTrackB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaTrackB*)
   {
      return GenerateInitInstanceLocal((::AnaTrackB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaTrackB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaTrackB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrackB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaVertexB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaVertexB_Dictionary();
   static void *new_AnaVertexB(void *p = 0);
   static void *newArray_AnaVertexB(Long_t size, void *p);
   static void delete_AnaVertexB(void *p);
   static void deleteArray_AnaVertexB(void *p);
   static void destruct_AnaVertexB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaVertexB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaVertexB) == sizeof( ::ROOTShadow::Shadow::AnaVertexB));
      ::AnaVertexB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaVertexB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaVertexB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 761,
                  typeid(::AnaVertexB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaVertexB_ShowMembers, &AnaVertexB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaVertexB) );
      instance.SetNew(&new_AnaVertexB);
      instance.SetNewArray(&newArray_AnaVertexB);
      instance.SetDelete(&delete_AnaVertexB);
      instance.SetDeleteArray(&deleteArray_AnaVertexB);
      instance.SetDestructor(&destruct_AnaVertexB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaVertexB*)
   {
      return GenerateInitInstanceLocal((::AnaVertexB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaVertexB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaVertexB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaVertexB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaBeamB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaBeamB_Dictionary();
   static void *new_AnaBeamB(void *p = 0);
   static void *newArray_AnaBeamB(Long_t size, void *p);
   static void delete_AnaBeamB(void *p);
   static void deleteArray_AnaBeamB(void *p);
   static void destruct_AnaBeamB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaBeamB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaBeamB) == sizeof( ::ROOTShadow::Shadow::AnaBeamB));
      ::AnaBeamB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaBeamB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaBeamB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 839,
                  typeid(::AnaBeamB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaBeamB_ShowMembers, &AnaBeamB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaBeamB) );
      instance.SetNew(&new_AnaBeamB);
      instance.SetNewArray(&newArray_AnaBeamB);
      instance.SetDelete(&delete_AnaBeamB);
      instance.SetDeleteArray(&deleteArray_AnaBeamB);
      instance.SetDestructor(&destruct_AnaBeamB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaBeamB*)
   {
      return GenerateInitInstanceLocal((::AnaBeamB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaBeamB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaBeamB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaBeamB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaDataQualityB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaDataQualityB_Dictionary();
   static void *new_AnaDataQualityB(void *p = 0);
   static void *newArray_AnaDataQualityB(Long_t size, void *p);
   static void delete_AnaDataQualityB(void *p);
   static void deleteArray_AnaDataQualityB(void *p);
   static void destruct_AnaDataQualityB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaDataQualityB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaDataQualityB) == sizeof( ::ROOTShadow::Shadow::AnaDataQualityB));
      ::AnaDataQualityB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaDataQualityB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaDataQualityB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 877,
                  typeid(::AnaDataQualityB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaDataQualityB_ShowMembers, &AnaDataQualityB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaDataQualityB) );
      instance.SetNew(&new_AnaDataQualityB);
      instance.SetNewArray(&newArray_AnaDataQualityB);
      instance.SetDelete(&delete_AnaDataQualityB);
      instance.SetDeleteArray(&deleteArray_AnaDataQualityB);
      instance.SetDestructor(&destruct_AnaDataQualityB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaDataQualityB*)
   {
      return GenerateInitInstanceLocal((::AnaDataQualityB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaDataQualityB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaDataQualityB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaDataQualityB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaDelayedClustersB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaDelayedClustersB_Dictionary();
   static void *new_AnaDelayedClustersB(void *p = 0);
   static void *newArray_AnaDelayedClustersB(Long_t size, void *p);
   static void delete_AnaDelayedClustersB(void *p);
   static void deleteArray_AnaDelayedClustersB(void *p);
   static void destruct_AnaDelayedClustersB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaDelayedClustersB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaDelayedClustersB) == sizeof( ::ROOTShadow::Shadow::AnaDelayedClustersB));
      ::AnaDelayedClustersB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaDelayedClustersB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaDelayedClustersB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 908,
                  typeid(::AnaDelayedClustersB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaDelayedClustersB_ShowMembers, &AnaDelayedClustersB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaDelayedClustersB) );
      instance.SetNew(&new_AnaDelayedClustersB);
      instance.SetNewArray(&newArray_AnaDelayedClustersB);
      instance.SetDelete(&delete_AnaDelayedClustersB);
      instance.SetDeleteArray(&deleteArray_AnaDelayedClustersB);
      instance.SetDestructor(&destruct_AnaDelayedClustersB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaDelayedClustersB*)
   {
      return GenerateInitInstanceLocal((::AnaDelayedClustersB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaDelayedClustersB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaDelayedClustersB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaDelayedClustersB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaBunchB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaBunchB_Dictionary();
   static void *new_AnaBunchB(void *p = 0);
   static void *newArray_AnaBunchB(Long_t size, void *p);
   static void delete_AnaBunchB(void *p);
   static void deleteArray_AnaBunchB(void *p);
   static void destruct_AnaBunchB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaBunchB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaBunchB) == sizeof( ::ROOTShadow::Shadow::AnaBunchB));
      ::AnaBunchB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaBunchB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaBunchB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 941,
                  typeid(::AnaBunchB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaBunchB_ShowMembers, &AnaBunchB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaBunchB) );
      instance.SetNew(&new_AnaBunchB);
      instance.SetNewArray(&newArray_AnaBunchB);
      instance.SetDelete(&delete_AnaBunchB);
      instance.SetDeleteArray(&deleteArray_AnaBunchB);
      instance.SetDestructor(&destruct_AnaBunchB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaBunchB*)
   {
      return GenerateInitInstanceLocal((::AnaBunchB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaBunchB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaBunchB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaBunchB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaFgdTimeBinB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaFgdTimeBinB_Dictionary();
   static void *new_AnaFgdTimeBinB(void *p = 0);
   static void *newArray_AnaFgdTimeBinB(Long_t size, void *p);
   static void delete_AnaFgdTimeBinB(void *p);
   static void deleteArray_AnaFgdTimeBinB(void *p);
   static void destruct_AnaFgdTimeBinB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaFgdTimeBinB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaFgdTimeBinB) == sizeof( ::ROOTShadow::Shadow::AnaFgdTimeBinB));
      ::AnaFgdTimeBinB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaFgdTimeBinB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaFgdTimeBinB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 981,
                  typeid(::AnaFgdTimeBinB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaFgdTimeBinB_ShowMembers, &AnaFgdTimeBinB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaFgdTimeBinB) );
      instance.SetNew(&new_AnaFgdTimeBinB);
      instance.SetNewArray(&newArray_AnaFgdTimeBinB);
      instance.SetDelete(&delete_AnaFgdTimeBinB);
      instance.SetDeleteArray(&deleteArray_AnaFgdTimeBinB);
      instance.SetDestructor(&destruct_AnaFgdTimeBinB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaFgdTimeBinB*)
   {
      return GenerateInitInstanceLocal((::AnaFgdTimeBinB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaFgdTimeBinB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaFgdTimeBinB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaFgdTimeBinB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaEventInfoB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaEventInfoB_Dictionary();
   static void *new_AnaEventInfoB(void *p = 0);
   static void *newArray_AnaEventInfoB(Long_t size, void *p);
   static void delete_AnaEventInfoB(void *p);
   static void deleteArray_AnaEventInfoB(void *p);
   static void destruct_AnaEventInfoB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaEventInfoB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaEventInfoB) == sizeof( ::ROOTShadow::Shadow::AnaEventInfoB));
      ::AnaEventInfoB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaEventInfoB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaEventInfoB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 1007,
                  typeid(::AnaEventInfoB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaEventInfoB_ShowMembers, &AnaEventInfoB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaEventInfoB) );
      instance.SetNew(&new_AnaEventInfoB);
      instance.SetNewArray(&newArray_AnaEventInfoB);
      instance.SetDelete(&delete_AnaEventInfoB);
      instance.SetDeleteArray(&deleteArray_AnaEventInfoB);
      instance.SetDestructor(&destruct_AnaEventInfoB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaEventInfoB*)
   {
      return GenerateInitInstanceLocal((::AnaEventInfoB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaEventInfoB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaEventInfoB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaEventInfoB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaSpillB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaSpillB_Dictionary();
   static void *new_AnaSpillB(void *p = 0);
   static void *newArray_AnaSpillB(Long_t size, void *p);
   static void delete_AnaSpillB(void *p);
   static void deleteArray_AnaSpillB(void *p);
   static void destruct_AnaSpillB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaSpillB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaSpillB) == sizeof( ::ROOTShadow::Shadow::AnaSpillB));
      ::AnaSpillB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaSpillB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaSpillB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 1063,
                  typeid(::AnaSpillB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaSpillB_ShowMembers, &AnaSpillB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaSpillB) );
      instance.SetNew(&new_AnaSpillB);
      instance.SetNewArray(&newArray_AnaSpillB);
      instance.SetDelete(&delete_AnaSpillB);
      instance.SetDeleteArray(&deleteArray_AnaSpillB);
      instance.SetDestructor(&destruct_AnaSpillB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaSpillB*)
   {
      return GenerateInitInstanceLocal((::AnaSpillB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaSpillB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaSpillB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaSpillB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   void AnaEventB_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void AnaEventB_Dictionary();
   static void *new_AnaEventB(void *p = 0);
   static void *newArray_AnaEventB(Long_t size, void *p);
   static void delete_AnaEventB(void *p);
   static void deleteArray_AnaEventB(void *p);
   static void destruct_AnaEventB(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const ::AnaEventB*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::AnaEventB) == sizeof( ::ROOTShadow::Shadow::AnaEventB));
      ::AnaEventB *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::AnaEventB),0);
      static ::ROOT::TGenericClassInfo 
         instance("AnaEventB", "/home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/inc/BaseDataClasses.hxx", 1236,
                  typeid(::AnaEventB), ::ROOT::DefineBehavior(ptr, ptr),
                  &AnaEventB_ShowMembers, &AnaEventB_Dictionary, isa_proxy, 4,
                  sizeof(::AnaEventB) );
      instance.SetNew(&new_AnaEventB);
      instance.SetNewArray(&newArray_AnaEventB);
      instance.SetDelete(&delete_AnaEventB);
      instance.SetDeleteArray(&deleteArray_AnaEventB);
      instance.SetDestructor(&destruct_AnaEventB);
      return &instance;
   }
   ROOT::TGenericClassInfo *GenerateInitInstance(const ::AnaEventB*)
   {
      return GenerateInitInstanceLocal((::AnaEventB*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::AnaEventB*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void AnaEventB_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const ::AnaEventB*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

//______________________________________________________________________________
namespace ROOTDict {
   void AnaParticleB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaParticleB.
      typedef ::ROOTShadow::Shadow::AnaParticleB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaParticleB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NHits", &sobj->NHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NNodes", &sobj->NNodes);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DirectionStart[3]", sobj->DirectionStart);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DirectionEnd[3]", sobj->DirectionEnd);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PositionStart[4]", sobj->PositionStart);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PositionEnd[4]", sobj->PositionEnd);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Original", &sobj->Original);
      R__insp.GenericShowMembers("AnaRecObjectC", ( ::AnaRecObjectC * )( (::AnaParticleB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaParticleB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaParticleB : new ::AnaParticleB;
   }
   static void *newArray_AnaParticleB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaParticleB[nElements] : new ::AnaParticleB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaParticleB(void *p) {
      delete ((::AnaParticleB*)p);
   }
   static void deleteArray_AnaParticleB(void *p) {
      delete [] ((::AnaParticleB*)p);
   }
   static void destruct_AnaParticleB(void *p) {
      typedef ::AnaParticleB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaParticleB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaParticleMomB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaParticleMomB.
      typedef ::ROOTShadow::Shadow::AnaParticleMomB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaParticleMomB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("AnaParticleB", ( ::AnaParticleB * )( (::AnaParticleMomB*) obj ), false);
      R__insp.GenericShowMembers("AnaParticleMomE", ( ::AnaParticleMomE * )( (::AnaParticleMomB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaParticleMomB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaParticleMomB : new ::AnaParticleMomB;
   }
   static void *newArray_AnaParticleMomB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaParticleMomB[nElements] : new ::AnaParticleMomB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaParticleMomB(void *p) {
      delete ((::AnaParticleMomB*)p);
   }
   static void deleteArray_AnaParticleMomB(void *p) {
      delete [] ((::AnaParticleMomB*)p);
   }
   static void destruct_AnaParticleMomB(void *p) {
      typedef ::AnaParticleMomB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaParticleMomB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaParticleMomE_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaParticleMomE.
      typedef ::ROOTShadow::Shadow::AnaParticleMomE ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaParticleMomE*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Charge", &sobj->Charge);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Momentum", &sobj->Momentum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MomentumEnd", &sobj->MomentumEnd);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaParticleMomE(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaParticleMomE : new ::AnaParticleMomE;
   }
   static void *newArray_AnaParticleMomE(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaParticleMomE[nElements] : new ::AnaParticleMomE[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaParticleMomE(void *p) {
      delete ((::AnaParticleMomE*)p);
   }
   static void deleteArray_AnaParticleMomE(void *p) {
      delete [] ((::AnaParticleMomE*)p);
   }
   static void destruct_AnaParticleMomE(void *p) {
      typedef ::AnaParticleMomE current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaParticleMomE

//______________________________________________________________________________
namespace ROOTDict {
   void AnaDelayedClustersB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaDelayedClustersB.
      typedef ::ROOTShadow::Shadow::AnaDelayedClustersB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaDelayedClustersB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MinTime", &sobj->MinTime);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MaxTime", &sobj->MaxTime);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NHits", &sobj->NHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RawChargeSum", &sobj->RawChargeSum);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaDelayedClustersB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaDelayedClustersB : new ::AnaDelayedClustersB;
   }
   static void *newArray_AnaDelayedClustersB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaDelayedClustersB[nElements] : new ::AnaDelayedClustersB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaDelayedClustersB(void *p) {
      delete ((::AnaDelayedClustersB*)p);
   }
   static void deleteArray_AnaDelayedClustersB(void *p) {
      delete [] ((::AnaDelayedClustersB*)p);
   }
   static void destruct_AnaDelayedClustersB(void *p) {
      typedef ::AnaDelayedClustersB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaDelayedClustersB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaSpillB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaSpillB.
      typedef ::ROOTShadow::Shadow::AnaSpillB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaSpillB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GeomID", &sobj->GeomID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*EventInfo", &sobj->EventInfo);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*DataQuality", &sobj->DataQuality);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Beam", &sobj->Beam);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NTotalTrueVertices", &sobj->NTotalTrueVertices);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NTotalTrueParticles", &sobj->NTotalTrueParticles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrueVertices", (void*)&sobj->TrueVertices);
      R__insp.InspectMember("vector<AnaTrueVertexB*>", (void*)&sobj->TrueVertices, "TrueVertices.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrueParticles", (void*)&sobj->TrueParticles);
      R__insp.InspectMember("vector<AnaTrueParticleB*>", (void*)&sobj->TrueParticles, "TrueParticles.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*OutOfBunch", &sobj->OutOfBunch);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FgdTimeBins", (void*)&sobj->FgdTimeBins);
      R__insp.InspectMember("vector<AnaFgdTimeBinB*>", (void*)&sobj->FgdTimeBins, "FgdTimeBins.", false);
      R__insp.GenericShowMembers("AnaSpillC", ( ::AnaSpillC * )( (::AnaSpillB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaSpillB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaSpillB : new ::AnaSpillB;
   }
   static void *newArray_AnaSpillB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaSpillB[nElements] : new ::AnaSpillB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaSpillB(void *p) {
      delete ((::AnaSpillB*)p);
   }
   static void deleteArray_AnaSpillB(void *p) {
      delete [] ((::AnaSpillB*)p);
   }
   static void destruct_AnaSpillB(void *p) {
      typedef ::AnaSpillB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaSpillB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaFgdTimeBinB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaFgdTimeBinB.
      typedef ::ROOTShadow::Shadow::AnaFgdTimeBinB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaFgdTimeBinB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MinTime", &sobj->MinTime);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NHits[2]", sobj->NHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RawChargeSum[2]", sobj->RawChargeSum);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaFgdTimeBinB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaFgdTimeBinB : new ::AnaFgdTimeBinB;
   }
   static void *newArray_AnaFgdTimeBinB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaFgdTimeBinB[nElements] : new ::AnaFgdTimeBinB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaFgdTimeBinB(void *p) {
      delete ((::AnaFgdTimeBinB*)p);
   }
   static void deleteArray_AnaFgdTimeBinB(void *p) {
      delete [] ((::AnaFgdTimeBinB*)p);
   }
   static void destruct_AnaFgdTimeBinB(void *p) {
      typedef ::AnaFgdTimeBinB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaFgdTimeBinB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaDataQualityB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaDataQualityB.
      typedef ::ROOTShadow::Shadow::AnaDataQualityB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaDataQualityB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GoodDaq", &sobj->GoodDaq);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GoodTimeDaq", &sobj->GoodTimeDaq);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaDataQualityB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaDataQualityB : new ::AnaDataQualityB;
   }
   static void *newArray_AnaDataQualityB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaDataQualityB[nElements] : new ::AnaDataQualityB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaDataQualityB(void *p) {
      delete ((::AnaDataQualityB*)p);
   }
   static void deleteArray_AnaDataQualityB(void *p) {
      delete [] ((::AnaDataQualityB*)p);
   }
   static void destruct_AnaDataQualityB(void *p) {
      typedef ::AnaDataQualityB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaDataQualityB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaEventInfoB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaEventInfoB.
      typedef ::ROOTShadow::Shadow::AnaEventInfoB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaEventInfoB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Run", &sobj->Run);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SubRun", &sobj->SubRun);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Event", &sobj->Event);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IsMC", &sobj->IsMC);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IsSand", &sobj->IsSand);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaEventInfoB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaEventInfoB : new ::AnaEventInfoB;
   }
   static void *newArray_AnaEventInfoB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaEventInfoB[nElements] : new ::AnaEventInfoB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaEventInfoB(void *p) {
      delete ((::AnaEventInfoB*)p);
   }
   static void deleteArray_AnaEventInfoB(void *p) {
      delete [] ((::AnaEventInfoB*)p);
   }
   static void destruct_AnaEventInfoB(void *p) {
      typedef ::AnaEventInfoB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaEventInfoB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaBeamB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaBeamB.
      typedef ::ROOTShadow::Shadow::AnaBeamB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaBeamB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GoodSpill", &sobj->GoodSpill);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "POTSincePreviousSavedSpill", &sobj->POTSincePreviousSavedSpill);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SpillsSincePreviousSavedSpill", &sobj->SpillsSincePreviousSavedSpill);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaBeamB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaBeamB : new ::AnaBeamB;
   }
   static void *newArray_AnaBeamB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaBeamB[nElements] : new ::AnaBeamB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaBeamB(void *p) {
      delete ((::AnaBeamB*)p);
   }
   static void deleteArray_AnaBeamB(void *p) {
      delete [] ((::AnaBeamB*)p);
   }
   static void destruct_AnaBeamB(void *p) {
      typedef ::AnaBeamB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaBeamB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaTrackB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaTrackB.
      typedef ::ROOTShadow::Shadow::AnaTrackB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrackB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IsFlipped", &sobj->IsFlipped);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Index", &sobj->Index);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RangeMomentumMuon", &sobj->RangeMomentumMuon);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RangeMomentumProton", &sobj->RangeMomentumProton);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RangeMomentumPion", &sobj->RangeMomentumPion);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MomentumFlip", &sobj->MomentumFlip);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TPCQualityCut", &sobj->TPCQualityCut);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ToF", (void*)&sobj->ToF);
      R__insp.InspectMember("AnaToF", (void*)&sobj->ToF, "ToF.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*TPCSegments[3]", &sobj->TPCSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nTPCSegments", &sobj->nTPCSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*FGDSegments[2]", &sobj->FGDSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nFGDSegments", &sobj->nFGDSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*ECALSegments[3]", &sobj->ECALSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nECALSegments", &sobj->nECALSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*SMRDSegments[4]", &sobj->SMRDSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nSMRDSegments", &sobj->nSMRDSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*P0DSegments[1]", &sobj->P0DSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nP0DSegments", &sobj->nP0DSegments);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TPCSegmentsVect", (void*)&sobj->TPCSegmentsVect);
      R__insp.InspectMember("vector<AnaTPCParticleB*>", (void*)&sobj->TPCSegmentsVect, "TPCSegmentsVect.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FGDSegmentsVect", (void*)&sobj->FGDSegmentsVect);
      R__insp.InspectMember("vector<AnaFGDParticleB*>", (void*)&sobj->FGDSegmentsVect, "FGDSegmentsVect.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ECALSegmentsVect", (void*)&sobj->ECALSegmentsVect);
      R__insp.InspectMember("vector<AnaECALParticleB*>", (void*)&sobj->ECALSegmentsVect, "ECALSegmentsVect.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "SMRDSegmentsVect", (void*)&sobj->SMRDSegmentsVect);
      R__insp.InspectMember("vector<AnaSMRDParticleB*>", (void*)&sobj->SMRDSegmentsVect, "SMRDSegmentsVect.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "P0DSegmentsVect", (void*)&sobj->P0DSegmentsVect);
      R__insp.InspectMember("vector<AnaP0DParticleB*>", (void*)&sobj->P0DSegmentsVect, "P0DSegmentsVect.", false);
      R__insp.GenericShowMembers("AnaParticleMomB", ( ::AnaParticleMomB * )( (::AnaTrackB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaTrackB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrackB : new ::AnaTrackB;
   }
   static void *newArray_AnaTrackB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrackB[nElements] : new ::AnaTrackB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaTrackB(void *p) {
      delete ((::AnaTrackB*)p);
   }
   static void deleteArray_AnaTrackB(void *p) {
      delete [] ((::AnaTrackB*)p);
   }
   static void destruct_AnaTrackB(void *p) {
      typedef ::AnaTrackB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaTrackB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaTPCParticleB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaTPCParticleB.
      typedef ::ROOTShadow::Shadow::AnaTPCParticleB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTPCParticleB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MomentumError", &sobj->MomentumError);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "RefitMomentum", &sobj->RefitMomentum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EFieldRefitMomentum", &sobj->EFieldRefitMomentum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxMeas", &sobj->dEdxMeas);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxexpMuon", &sobj->dEdxexpMuon);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxexpEle", &sobj->dEdxexpEle);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxexpPion", &sobj->dEdxexpPion);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxexpProton", &sobj->dEdxexpProton);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxSigmaMuon", &sobj->dEdxSigmaMuon);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxSigmaEle", &sobj->dEdxSigmaEle);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxSigmaPion", &sobj->dEdxSigmaPion);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "dEdxSigmaProton", &sobj->dEdxSigmaProton);
      R__insp.GenericShowMembers("AnaParticleMomB", ( ::AnaParticleMomB * )( (::AnaTPCParticleB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaTPCParticleB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTPCParticleB : new ::AnaTPCParticleB;
   }
   static void *newArray_AnaTPCParticleB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTPCParticleB[nElements] : new ::AnaTPCParticleB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaTPCParticleB(void *p) {
      delete ((::AnaTPCParticleB*)p);
   }
   static void deleteArray_AnaTPCParticleB(void *p) {
      delete [] ((::AnaTPCParticleB*)p);
   }
   static void destruct_AnaTPCParticleB(void *p) {
      typedef ::AnaTPCParticleB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaTPCParticleB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaFGDParticleB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaFGDParticleB.
      typedef ::ROOTShadow::Shadow::AnaFGDParticleB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaFGDParticleB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "X", &sobj->X);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "E", &sobj->E);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Pullmu", &sobj->Pullmu);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Pullp", &sobj->Pullp);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Pullpi", &sobj->Pullpi);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Pullno", &sobj->Pullno);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Pulle", &sobj->Pulle);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Containment", &sobj->Containment);
      R__insp.GenericShowMembers("AnaParticleB", ( ::AnaParticleB * )( (::AnaFGDParticleB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaFGDParticleB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaFGDParticleB : new ::AnaFGDParticleB;
   }
   static void *newArray_AnaFGDParticleB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaFGDParticleB[nElements] : new ::AnaFGDParticleB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaFGDParticleB(void *p) {
      delete ((::AnaFGDParticleB*)p);
   }
   static void deleteArray_AnaFGDParticleB(void *p) {
      delete [] ((::AnaFGDParticleB*)p);
   }
   static void destruct_AnaFGDParticleB(void *p) {
      typedef ::AnaFGDParticleB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaFGDParticleB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaECALParticleB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaECALParticleB.
      typedef ::ROOTShadow::Shadow::AnaECALParticleB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaECALParticleB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Clustering3DSeedType", &sobj->Clustering3DSeedType);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ClusteringAdded3DClusterHits", &sobj->ClusteringAdded3DClusterHits);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PIDQuality", &sobj->PIDQuality);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PIDMipEm", &sobj->PIDMipEm);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PIDMipPion", &sobj->PIDMipPion);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PIDEmHip", &sobj->PIDEmHip);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Length", &sobj->Length);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EMEnergy", &sobj->EMEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EDeposit", &sobj->EDeposit);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IsShowerLike", &sobj->IsShowerLike);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "AvgTime", &sobj->AvgTime);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "MostUpStreamLayerHit", &sobj->MostUpStreamLayerHit);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ShowerPosition[3]", sobj->ShowerPosition);
      R__insp.GenericShowMembers("AnaParticleB", ( ::AnaParticleB * )( (::AnaECALParticleB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaECALParticleB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaECALParticleB : new ::AnaECALParticleB;
   }
   static void *newArray_AnaECALParticleB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaECALParticleB[nElements] : new ::AnaECALParticleB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaECALParticleB(void *p) {
      delete ((::AnaECALParticleB*)p);
   }
   static void deleteArray_AnaECALParticleB(void *p) {
      delete [] ((::AnaECALParticleB*)p);
   }
   static void destruct_AnaECALParticleB(void *p) {
      typedef ::AnaECALParticleB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaECALParticleB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaP0DParticleB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaP0DParticleB.
      typedef ::ROOTShadow::Shadow::AnaP0DParticleB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaP0DParticleB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Length", &sobj->Length);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ELoss", &sobj->ELoss);
      R__insp.GenericShowMembers("AnaParticleB", ( ::AnaParticleB * )( (::AnaP0DParticleB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaP0DParticleB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaP0DParticleB : new ::AnaP0DParticleB;
   }
   static void *newArray_AnaP0DParticleB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaP0DParticleB[nElements] : new ::AnaP0DParticleB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaP0DParticleB(void *p) {
      delete ((::AnaP0DParticleB*)p);
   }
   static void deleteArray_AnaP0DParticleB(void *p) {
      delete [] ((::AnaP0DParticleB*)p);
   }
   static void destruct_AnaP0DParticleB(void *p) {
      typedef ::AnaP0DParticleB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaP0DParticleB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaSMRDParticleB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaSMRDParticleB.
      typedef ::ROOTShadow::Shadow::AnaSMRDParticleB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaSMRDParticleB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "AvgTime", &sobj->AvgTime);
      R__insp.GenericShowMembers("AnaParticleB", ( ::AnaParticleB * )( (::AnaSMRDParticleB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaSMRDParticleB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaSMRDParticleB : new ::AnaSMRDParticleB;
   }
   static void *newArray_AnaSMRDParticleB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaSMRDParticleB[nElements] : new ::AnaSMRDParticleB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaSMRDParticleB(void *p) {
      delete ((::AnaSMRDParticleB*)p);
   }
   static void deleteArray_AnaSMRDParticleB(void *p) {
      delete [] ((::AnaSMRDParticleB*)p);
   }
   static void destruct_AnaSMRDParticleB(void *p) {
      typedef ::AnaSMRDParticleB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaSMRDParticleB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaTrackerTrackB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaTrackerTrackB.
      typedef ::ROOTShadow::Shadow::AnaTrackerTrackB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrackerTrackB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.GenericShowMembers("AnaParticleMomB", ( ::AnaParticleMomB * )( (::AnaTrackerTrackB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaTrackerTrackB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrackerTrackB : new ::AnaTrackerTrackB;
   }
   static void *newArray_AnaTrackerTrackB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrackerTrackB[nElements] : new ::AnaTrackerTrackB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaTrackerTrackB(void *p) {
      delete ((::AnaTrackerTrackB*)p);
   }
   static void deleteArray_AnaTrackerTrackB(void *p) {
      delete [] ((::AnaTrackerTrackB*)p);
   }
   static void destruct_AnaTrackerTrackB(void *p) {
      typedef ::AnaTrackerTrackB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaTrackerTrackB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaVertexB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaVertexB.
      typedef ::ROOTShadow::Shadow::AnaVertexB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaVertexB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Bunch", &sobj->Bunch);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PrimaryIndex", &sobj->PrimaryIndex);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Position[4]", sobj->Position);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Particles", &sobj->Particles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nParticles", &sobj->nParticles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ParticlesIDsVect", (void*)&sobj->ParticlesIDsVect);
      R__insp.InspectMember("vector<Int_t>", (void*)&sobj->ParticlesIDsVect, "ParticlesIDsVect.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*TrueVertex", &sobj->TrueVertex);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrueVerticesMatch", (void*)&sobj->TrueVerticesMatch);
      R__insp.InspectMember("vector<std::pair<AnaTrueVertexB*,AnaRecTrueMatchB> >", (void*)&sobj->TrueVerticesMatch, "TrueVerticesMatch.", true);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Original", &sobj->Original);
      R__insp.GenericShowMembers("AnaRecObjectC", ( ::AnaRecObjectC * )( (::AnaVertexB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaVertexB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaVertexB : new ::AnaVertexB;
   }
   static void *newArray_AnaVertexB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaVertexB[nElements] : new ::AnaVertexB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaVertexB(void *p) {
      delete ((::AnaVertexB*)p);
   }
   static void deleteArray_AnaVertexB(void *p) {
      delete [] ((::AnaVertexB*)p);
   }
   static void destruct_AnaVertexB(void *p) {
      typedef ::AnaVertexB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaVertexB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaBunchB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaBunchB.
      typedef ::ROOTShadow::Shadow::AnaBunchB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaBunchB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Vertices", (void*)&sobj->Vertices);
      R__insp.InspectMember("vector<AnaVertexB*>", (void*)&sobj->Vertices, "Vertices.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Particles", (void*)&sobj->Particles);
      R__insp.InspectMember("vector<AnaParticleB*>", (void*)&sobj->Particles, "Particles.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*DelayedClusters", &sobj->DelayedClusters);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nDelayedClusters", &sobj->nDelayedClusters);
      R__insp.GenericShowMembers("AnaBunchC", ( ::AnaBunchC * )( (::AnaBunchB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaBunchB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaBunchB : new ::AnaBunchB;
   }
   static void *newArray_AnaBunchB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaBunchB[nElements] : new ::AnaBunchB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaBunchB(void *p) {
      delete ((::AnaBunchB*)p);
   }
   static void deleteArray_AnaBunchB(void *p) {
      delete [] ((::AnaBunchB*)p);
   }
   static void destruct_AnaBunchB(void *p) {
      typedef ::AnaBunchB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaBunchB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaEventB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaEventB.
      typedef ::ROOTShadow::Shadow::AnaEventB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaEventB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EventInfo", (void*)&sobj->EventInfo);
      R__insp.InspectMember("AnaEventInfoB", (void*)&sobj->EventInfo, "EventInfo.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*DataQuality", &sobj->DataQuality);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Beam", &sobj->Beam);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Bunch", &sobj->Bunch);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Particles", &sobj->Particles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nParticles", &sobj->nParticles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*Vertices", &sobj->Vertices);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nVertices", &sobj->nVertices);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*FgdTimeBins", &sobj->FgdTimeBins);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nFgdTimeBins", &sobj->nFgdTimeBins);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*DelayedClusters", &sobj->DelayedClusters);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nDelayedClusters", &sobj->nDelayedClusters);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*TrueParticles", &sobj->TrueParticles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nTrueParticles", &sobj->nTrueParticles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*TrueVertices", &sobj->TrueVertices);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nTrueVertices", &sobj->nTrueVertices);
      R__insp.GenericShowMembers("AnaEventC", ( ::AnaEventC * )( (::AnaEventB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaEventB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaEventB : new ::AnaEventB;
   }
   static void *newArray_AnaEventB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaEventB[nElements] : new ::AnaEventB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaEventB(void *p) {
      delete ((::AnaEventB*)p);
   }
   static void deleteArray_AnaEventB(void *p) {
      delete [] ((::AnaEventB*)p);
   }
   static void destruct_AnaEventB(void *p) {
      typedef ::AnaEventB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaEventB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaTrueParticleB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaTrueParticleB.
      typedef ::ROOTShadow::Shadow::AnaTrueParticleB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrueParticleB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PDG", &sobj->PDG);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PrimaryID", &sobj->PrimaryID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ParentID", &sobj->ParentID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ParentPDG", &sobj->ParentPDG);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GParentID", &sobj->GParentID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "GParentPDG", &sobj->GParentPDG);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Position[4]", sobj->Position);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "PositionEnd[4]", sobj->PositionEnd);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Direction[3]", sobj->Direction);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Momentum", &sobj->Momentum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Charge", &sobj->Charge);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "VertexID", &sobj->VertexID);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*TrueVertex", &sobj->TrueVertex);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*DetCrossings", &sobj->DetCrossings);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nDetCrossings", &sobj->nDetCrossings);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DetCrossingsVect", (void*)&sobj->DetCrossingsVect);
      R__insp.InspectMember("vector<AnaDetCrossingB*>", (void*)&sobj->DetCrossingsVect, "DetCrossingsVect.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IsTruePrimaryPi0DecayPhoton", &sobj->IsTruePrimaryPi0DecayPhoton);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "IsTruePrimaryPi0DecayPhotonChild", &sobj->IsTruePrimaryPi0DecayPhotonChild);
      R__insp.GenericShowMembers("AnaTrueObjectC", ( ::AnaTrueObjectC * )( (::AnaTrueParticleB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaTrueParticleB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrueParticleB : new ::AnaTrueParticleB;
   }
   static void *newArray_AnaTrueParticleB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrueParticleB[nElements] : new ::AnaTrueParticleB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaTrueParticleB(void *p) {
      delete ((::AnaTrueParticleB*)p);
   }
   static void deleteArray_AnaTrueParticleB(void *p) {
      delete [] ((::AnaTrueParticleB*)p);
   }
   static void destruct_AnaTrueParticleB(void *p) {
      typedef ::AnaTrueParticleB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaTrueParticleB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaTrueVertexB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaTrueVertexB.
      typedef ::ROOTShadow::Shadow::AnaTrueVertexB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaTrueVertexB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NuPDG", &sobj->NuPDG);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "NuEnergy", &sobj->NuEnergy);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Position[4]", sobj->Position);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Bunch", &sobj->Bunch);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*TrueParticles", &sobj->TrueParticles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "nTrueParticles", &sobj->nTrueParticles);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "TrueParticlesIDsVect", (void*)&sobj->TrueParticlesIDsVect);
      R__insp.InspectMember("vector<Int_t>", (void*)&sobj->TrueParticlesIDsVect, "TrueParticlesIDsVect.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Detector", &sobj->Detector);
      R__insp.GenericShowMembers("AnaTrueObjectC", ( ::AnaTrueObjectC * )( (::AnaTrueVertexB*) obj ), false);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaTrueVertexB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrueVertexB : new ::AnaTrueVertexB;
   }
   static void *newArray_AnaTrueVertexB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaTrueVertexB[nElements] : new ::AnaTrueVertexB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaTrueVertexB(void *p) {
      delete ((::AnaTrueVertexB*)p);
   }
   static void deleteArray_AnaTrueVertexB(void *p) {
      delete [] ((::AnaTrueVertexB*)p);
   }
   static void destruct_AnaTrueVertexB(void *p) {
      typedef ::AnaTrueVertexB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaTrueVertexB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaDetCrossingB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaDetCrossingB.
      typedef ::ROOTShadow::Shadow::AnaDetCrossingB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaDetCrossingB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EntrancePosition[4]", sobj->EntrancePosition);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ExitPosition[4]", sobj->ExitPosition);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EntranceMomentum[3]", sobj->EntranceMomentum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ExitMomentum[3]", sobj->ExitMomentum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "InActive", &sobj->InActive);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Detector", &sobj->Detector);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ExitOK", &sobj->ExitOK);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "EntranceOK", &sobj->EntranceOK);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaDetCrossingB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaDetCrossingB : new ::AnaDetCrossingB;
   }
   static void *newArray_AnaDetCrossingB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaDetCrossingB[nElements] : new ::AnaDetCrossingB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaDetCrossingB(void *p) {
      delete ((::AnaDetCrossingB*)p);
   }
   static void deleteArray_AnaDetCrossingB(void *p) {
      delete [] ((::AnaDetCrossingB*)p);
   }
   static void destruct_AnaDetCrossingB(void *p) {
      typedef ::AnaDetCrossingB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaDetCrossingB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaRecTrueMatchB_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaRecTrueMatchB.
      typedef ::ROOTShadow::Shadow::AnaRecTrueMatchB ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaRecTrueMatchB*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Cleanliness", &sobj->Cleanliness);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Completeness", &sobj->Completeness);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaRecTrueMatchB(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaRecTrueMatchB : new ::AnaRecTrueMatchB;
   }
   static void *newArray_AnaRecTrueMatchB(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaRecTrueMatchB[nElements] : new ::AnaRecTrueMatchB[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaRecTrueMatchB(void *p) {
      delete ((::AnaRecTrueMatchB*)p);
   }
   static void deleteArray_AnaRecTrueMatchB(void *p) {
      delete [] ((::AnaRecTrueMatchB*)p);
   }
   static void destruct_AnaRecTrueMatchB(void *p) {
      typedef ::AnaRecTrueMatchB current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaRecTrueMatchB

//______________________________________________________________________________
namespace ROOTDict {
   void AnaToF_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class AnaToF.
      typedef ::ROOTShadow::Shadow::AnaToF ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOTDict::GenerateInitInstanceLocal((const ::AnaToF*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "FGD1_FGD2", &sobj->FGD1_FGD2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Flag_FGD1_FGD2", &sobj->Flag_FGD1_FGD2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "P0D_FGD1", &sobj->P0D_FGD1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Flag_P0D_FGD1", &sobj->Flag_P0D_FGD1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DSECal_FGD1", &sobj->DSECal_FGD1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Flag_DSECal_FGD1", &sobj->Flag_DSECal_FGD1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ECal_FGD1", &sobj->ECal_FGD1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Flag_ECal_FGD1", &sobj->Flag_ECal_FGD1);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "ECal_FGD2", &sobj->ECal_FGD2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Flag_ECal_FGD2", &sobj->Flag_ECal_FGD2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "DSECal_FGD2", &sobj->DSECal_FGD2);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "Flag_DSECal_FGD2", &sobj->Flag_DSECal_FGD2);
   }

}

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_AnaToF(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaToF : new ::AnaToF;
   }
   static void *newArray_AnaToF(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::AnaToF[nElements] : new ::AnaToF[nElements];
   }
   // Wrapper around operator delete
   static void delete_AnaToF(void *p) {
      delete ((::AnaToF*)p);
   }
   static void deleteArray_AnaToF(void *p) {
      delete [] ((::AnaToF*)p);
   }
   static void destruct_AnaToF(void *p) {
      typedef ::AnaToF current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class ::AnaToF

namespace ROOTDict {
   void vectorlEAnaDetCrossingBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaDetCrossingBmUgR_Dictionary();
   static void *new_vectorlEAnaDetCrossingBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaDetCrossingBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaDetCrossingBmUgR(void *p);
   static void deleteArray_vectorlEAnaDetCrossingBmUgR(void *p);
   static void destruct_vectorlEAnaDetCrossingBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaDetCrossingB*>*)
   {
      vector<AnaDetCrossingB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaDetCrossingB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaDetCrossingB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaDetCrossingB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaDetCrossingBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaDetCrossingB*>) );
      instance.SetNew(&new_vectorlEAnaDetCrossingBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaDetCrossingBmUgR);
      instance.SetDelete(&delete_vectorlEAnaDetCrossingBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaDetCrossingBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaDetCrossingBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaDetCrossingB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaDetCrossingB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaDetCrossingBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaDetCrossingB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaDetCrossingBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaDetCrossingB*> : new vector<AnaDetCrossingB*>;
   }
   static void *newArray_vectorlEAnaDetCrossingBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaDetCrossingB*>[nElements] : new vector<AnaDetCrossingB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaDetCrossingBmUgR(void *p) {
      delete ((vector<AnaDetCrossingB*>*)p);
   }
   static void deleteArray_vectorlEAnaDetCrossingBmUgR(void *p) {
      delete [] ((vector<AnaDetCrossingB*>*)p);
   }
   static void destruct_vectorlEAnaDetCrossingBmUgR(void *p) {
      typedef vector<AnaDetCrossingB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaDetCrossingB*>

namespace ROOTDict {
   void vectorlEAnaECALParticleBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaECALParticleBmUgR_Dictionary();
   static void *new_vectorlEAnaECALParticleBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaECALParticleBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaECALParticleBmUgR(void *p);
   static void deleteArray_vectorlEAnaECALParticleBmUgR(void *p);
   static void destruct_vectorlEAnaECALParticleBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaECALParticleB*>*)
   {
      vector<AnaECALParticleB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaECALParticleB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaECALParticleB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaECALParticleB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaECALParticleBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaECALParticleB*>) );
      instance.SetNew(&new_vectorlEAnaECALParticleBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaECALParticleBmUgR);
      instance.SetDelete(&delete_vectorlEAnaECALParticleBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaECALParticleBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaECALParticleBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaECALParticleB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaECALParticleB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaECALParticleBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaECALParticleB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaECALParticleBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaECALParticleB*> : new vector<AnaECALParticleB*>;
   }
   static void *newArray_vectorlEAnaECALParticleBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaECALParticleB*>[nElements] : new vector<AnaECALParticleB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaECALParticleBmUgR(void *p) {
      delete ((vector<AnaECALParticleB*>*)p);
   }
   static void deleteArray_vectorlEAnaECALParticleBmUgR(void *p) {
      delete [] ((vector<AnaECALParticleB*>*)p);
   }
   static void destruct_vectorlEAnaECALParticleBmUgR(void *p) {
      typedef vector<AnaECALParticleB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaECALParticleB*>

namespace ROOTDict {
   void vectorlEAnaFGDParticleBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaFGDParticleBmUgR_Dictionary();
   static void *new_vectorlEAnaFGDParticleBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaFGDParticleBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaFGDParticleBmUgR(void *p);
   static void deleteArray_vectorlEAnaFGDParticleBmUgR(void *p);
   static void destruct_vectorlEAnaFGDParticleBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaFGDParticleB*>*)
   {
      vector<AnaFGDParticleB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaFGDParticleB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaFGDParticleB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaFGDParticleB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaFGDParticleBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaFGDParticleB*>) );
      instance.SetNew(&new_vectorlEAnaFGDParticleBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaFGDParticleBmUgR);
      instance.SetDelete(&delete_vectorlEAnaFGDParticleBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaFGDParticleBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaFGDParticleBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaFGDParticleB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaFGDParticleB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaFGDParticleBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaFGDParticleB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaFGDParticleBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaFGDParticleB*> : new vector<AnaFGDParticleB*>;
   }
   static void *newArray_vectorlEAnaFGDParticleBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaFGDParticleB*>[nElements] : new vector<AnaFGDParticleB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaFGDParticleBmUgR(void *p) {
      delete ((vector<AnaFGDParticleB*>*)p);
   }
   static void deleteArray_vectorlEAnaFGDParticleBmUgR(void *p) {
      delete [] ((vector<AnaFGDParticleB*>*)p);
   }
   static void destruct_vectorlEAnaFGDParticleBmUgR(void *p) {
      typedef vector<AnaFGDParticleB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaFGDParticleB*>

namespace ROOTDict {
   void vectorlEAnaFgdTimeBinBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaFgdTimeBinBmUgR_Dictionary();
   static void *new_vectorlEAnaFgdTimeBinBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaFgdTimeBinBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaFgdTimeBinBmUgR(void *p);
   static void deleteArray_vectorlEAnaFgdTimeBinBmUgR(void *p);
   static void destruct_vectorlEAnaFgdTimeBinBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaFgdTimeBinB*>*)
   {
      vector<AnaFgdTimeBinB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaFgdTimeBinB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaFgdTimeBinB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaFgdTimeBinB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaFgdTimeBinBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaFgdTimeBinB*>) );
      instance.SetNew(&new_vectorlEAnaFgdTimeBinBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaFgdTimeBinBmUgR);
      instance.SetDelete(&delete_vectorlEAnaFgdTimeBinBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaFgdTimeBinBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaFgdTimeBinBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaFgdTimeBinB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaFgdTimeBinB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaFgdTimeBinBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaFgdTimeBinB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaFgdTimeBinBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaFgdTimeBinB*> : new vector<AnaFgdTimeBinB*>;
   }
   static void *newArray_vectorlEAnaFgdTimeBinBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaFgdTimeBinB*>[nElements] : new vector<AnaFgdTimeBinB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaFgdTimeBinBmUgR(void *p) {
      delete ((vector<AnaFgdTimeBinB*>*)p);
   }
   static void deleteArray_vectorlEAnaFgdTimeBinBmUgR(void *p) {
      delete [] ((vector<AnaFgdTimeBinB*>*)p);
   }
   static void destruct_vectorlEAnaFgdTimeBinBmUgR(void *p) {
      typedef vector<AnaFgdTimeBinB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaFgdTimeBinB*>

namespace ROOTDict {
   void vectorlEAnaP0DParticleBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaP0DParticleBmUgR_Dictionary();
   static void *new_vectorlEAnaP0DParticleBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaP0DParticleBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaP0DParticleBmUgR(void *p);
   static void deleteArray_vectorlEAnaP0DParticleBmUgR(void *p);
   static void destruct_vectorlEAnaP0DParticleBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaP0DParticleB*>*)
   {
      vector<AnaP0DParticleB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaP0DParticleB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaP0DParticleB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaP0DParticleB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaP0DParticleBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaP0DParticleB*>) );
      instance.SetNew(&new_vectorlEAnaP0DParticleBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaP0DParticleBmUgR);
      instance.SetDelete(&delete_vectorlEAnaP0DParticleBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaP0DParticleBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaP0DParticleBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaP0DParticleB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaP0DParticleB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaP0DParticleBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaP0DParticleB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaP0DParticleBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaP0DParticleB*> : new vector<AnaP0DParticleB*>;
   }
   static void *newArray_vectorlEAnaP0DParticleBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaP0DParticleB*>[nElements] : new vector<AnaP0DParticleB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaP0DParticleBmUgR(void *p) {
      delete ((vector<AnaP0DParticleB*>*)p);
   }
   static void deleteArray_vectorlEAnaP0DParticleBmUgR(void *p) {
      delete [] ((vector<AnaP0DParticleB*>*)p);
   }
   static void destruct_vectorlEAnaP0DParticleBmUgR(void *p) {
      typedef vector<AnaP0DParticleB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaP0DParticleB*>

namespace ROOTDict {
   void vectorlEAnaParticleBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaParticleBmUgR_Dictionary();
   static void *new_vectorlEAnaParticleBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaParticleBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaParticleBmUgR(void *p);
   static void deleteArray_vectorlEAnaParticleBmUgR(void *p);
   static void destruct_vectorlEAnaParticleBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaParticleB*>*)
   {
      vector<AnaParticleB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaParticleB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaParticleB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaParticleB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaParticleBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaParticleB*>) );
      instance.SetNew(&new_vectorlEAnaParticleBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaParticleBmUgR);
      instance.SetDelete(&delete_vectorlEAnaParticleBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaParticleBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaParticleBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaParticleB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaParticleB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaParticleBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaParticleB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaParticleBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaParticleB*> : new vector<AnaParticleB*>;
   }
   static void *newArray_vectorlEAnaParticleBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaParticleB*>[nElements] : new vector<AnaParticleB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaParticleBmUgR(void *p) {
      delete ((vector<AnaParticleB*>*)p);
   }
   static void deleteArray_vectorlEAnaParticleBmUgR(void *p) {
      delete [] ((vector<AnaParticleB*>*)p);
   }
   static void destruct_vectorlEAnaParticleBmUgR(void *p) {
      typedef vector<AnaParticleB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaParticleB*>

namespace ROOTDict {
   void vectorlEAnaSMRDParticleBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaSMRDParticleBmUgR_Dictionary();
   static void *new_vectorlEAnaSMRDParticleBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaSMRDParticleBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaSMRDParticleBmUgR(void *p);
   static void deleteArray_vectorlEAnaSMRDParticleBmUgR(void *p);
   static void destruct_vectorlEAnaSMRDParticleBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaSMRDParticleB*>*)
   {
      vector<AnaSMRDParticleB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaSMRDParticleB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaSMRDParticleB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaSMRDParticleB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaSMRDParticleBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaSMRDParticleB*>) );
      instance.SetNew(&new_vectorlEAnaSMRDParticleBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaSMRDParticleBmUgR);
      instance.SetDelete(&delete_vectorlEAnaSMRDParticleBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaSMRDParticleBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaSMRDParticleBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaSMRDParticleB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaSMRDParticleB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaSMRDParticleBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaSMRDParticleB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaSMRDParticleBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaSMRDParticleB*> : new vector<AnaSMRDParticleB*>;
   }
   static void *newArray_vectorlEAnaSMRDParticleBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaSMRDParticleB*>[nElements] : new vector<AnaSMRDParticleB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaSMRDParticleBmUgR(void *p) {
      delete ((vector<AnaSMRDParticleB*>*)p);
   }
   static void deleteArray_vectorlEAnaSMRDParticleBmUgR(void *p) {
      delete [] ((vector<AnaSMRDParticleB*>*)p);
   }
   static void destruct_vectorlEAnaSMRDParticleBmUgR(void *p) {
      typedef vector<AnaSMRDParticleB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaSMRDParticleB*>

namespace ROOTDict {
   void vectorlEAnaTPCParticleBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaTPCParticleBmUgR_Dictionary();
   static void *new_vectorlEAnaTPCParticleBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaTPCParticleBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaTPCParticleBmUgR(void *p);
   static void deleteArray_vectorlEAnaTPCParticleBmUgR(void *p);
   static void destruct_vectorlEAnaTPCParticleBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaTPCParticleB*>*)
   {
      vector<AnaTPCParticleB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaTPCParticleB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaTPCParticleB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaTPCParticleB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaTPCParticleBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaTPCParticleB*>) );
      instance.SetNew(&new_vectorlEAnaTPCParticleBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaTPCParticleBmUgR);
      instance.SetDelete(&delete_vectorlEAnaTPCParticleBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaTPCParticleBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaTPCParticleBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaTPCParticleB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaTPCParticleB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaTPCParticleBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaTPCParticleB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaTPCParticleBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaTPCParticleB*> : new vector<AnaTPCParticleB*>;
   }
   static void *newArray_vectorlEAnaTPCParticleBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaTPCParticleB*>[nElements] : new vector<AnaTPCParticleB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaTPCParticleBmUgR(void *p) {
      delete ((vector<AnaTPCParticleB*>*)p);
   }
   static void deleteArray_vectorlEAnaTPCParticleBmUgR(void *p) {
      delete [] ((vector<AnaTPCParticleB*>*)p);
   }
   static void destruct_vectorlEAnaTPCParticleBmUgR(void *p) {
      typedef vector<AnaTPCParticleB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaTPCParticleB*>

namespace ROOTDict {
   void vectorlEAnaTrueParticleBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaTrueParticleBmUgR_Dictionary();
   static void *new_vectorlEAnaTrueParticleBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaTrueParticleBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaTrueParticleBmUgR(void *p);
   static void deleteArray_vectorlEAnaTrueParticleBmUgR(void *p);
   static void destruct_vectorlEAnaTrueParticleBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaTrueParticleB*>*)
   {
      vector<AnaTrueParticleB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaTrueParticleB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaTrueParticleB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaTrueParticleB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaTrueParticleBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaTrueParticleB*>) );
      instance.SetNew(&new_vectorlEAnaTrueParticleBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaTrueParticleBmUgR);
      instance.SetDelete(&delete_vectorlEAnaTrueParticleBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaTrueParticleBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaTrueParticleBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaTrueParticleB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaTrueParticleB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaTrueParticleBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaTrueParticleB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaTrueParticleBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaTrueParticleB*> : new vector<AnaTrueParticleB*>;
   }
   static void *newArray_vectorlEAnaTrueParticleBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaTrueParticleB*>[nElements] : new vector<AnaTrueParticleB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaTrueParticleBmUgR(void *p) {
      delete ((vector<AnaTrueParticleB*>*)p);
   }
   static void deleteArray_vectorlEAnaTrueParticleBmUgR(void *p) {
      delete [] ((vector<AnaTrueParticleB*>*)p);
   }
   static void destruct_vectorlEAnaTrueParticleBmUgR(void *p) {
      typedef vector<AnaTrueParticleB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaTrueParticleB*>

namespace ROOTDict {
   void vectorlEAnaTrueVertexBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaTrueVertexBmUgR_Dictionary();
   static void *new_vectorlEAnaTrueVertexBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaTrueVertexBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaTrueVertexBmUgR(void *p);
   static void deleteArray_vectorlEAnaTrueVertexBmUgR(void *p);
   static void destruct_vectorlEAnaTrueVertexBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaTrueVertexB*>*)
   {
      vector<AnaTrueVertexB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaTrueVertexB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaTrueVertexB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaTrueVertexB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaTrueVertexBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaTrueVertexB*>) );
      instance.SetNew(&new_vectorlEAnaTrueVertexBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaTrueVertexBmUgR);
      instance.SetDelete(&delete_vectorlEAnaTrueVertexBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaTrueVertexBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaTrueVertexBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaTrueVertexB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaTrueVertexB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaTrueVertexBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaTrueVertexB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaTrueVertexBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaTrueVertexB*> : new vector<AnaTrueVertexB*>;
   }
   static void *newArray_vectorlEAnaTrueVertexBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaTrueVertexB*>[nElements] : new vector<AnaTrueVertexB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaTrueVertexBmUgR(void *p) {
      delete ((vector<AnaTrueVertexB*>*)p);
   }
   static void deleteArray_vectorlEAnaTrueVertexBmUgR(void *p) {
      delete [] ((vector<AnaTrueVertexB*>*)p);
   }
   static void destruct_vectorlEAnaTrueVertexBmUgR(void *p) {
      typedef vector<AnaTrueVertexB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaTrueVertexB*>

namespace ROOTDict {
   void vectorlEAnaVertexBmUgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEAnaVertexBmUgR_Dictionary();
   static void *new_vectorlEAnaVertexBmUgR(void *p = 0);
   static void *newArray_vectorlEAnaVertexBmUgR(Long_t size, void *p);
   static void delete_vectorlEAnaVertexBmUgR(void *p);
   static void deleteArray_vectorlEAnaVertexBmUgR(void *p);
   static void destruct_vectorlEAnaVertexBmUgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<AnaVertexB*>*)
   {
      vector<AnaVertexB*> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<AnaVertexB*>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<AnaVertexB*>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<AnaVertexB*>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEAnaVertexBmUgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<AnaVertexB*>) );
      instance.SetNew(&new_vectorlEAnaVertexBmUgR);
      instance.SetNewArray(&newArray_vectorlEAnaVertexBmUgR);
      instance.SetDelete(&delete_vectorlEAnaVertexBmUgR);
      instance.SetDeleteArray(&deleteArray_vectorlEAnaVertexBmUgR);
      instance.SetDestructor(&destruct_vectorlEAnaVertexBmUgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<AnaVertexB*> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<AnaVertexB*>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEAnaVertexBmUgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<AnaVertexB*>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEAnaVertexBmUgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaVertexB*> : new vector<AnaVertexB*>;
   }
   static void *newArray_vectorlEAnaVertexBmUgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<AnaVertexB*>[nElements] : new vector<AnaVertexB*>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEAnaVertexBmUgR(void *p) {
      delete ((vector<AnaVertexB*>*)p);
   }
   static void deleteArray_vectorlEAnaVertexBmUgR(void *p) {
      delete [] ((vector<AnaVertexB*>*)p);
   }
   static void destruct_vectorlEAnaVertexBmUgR(void *p) {
      typedef vector<AnaVertexB*> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<AnaVertexB*>

namespace ROOTDict {
   void vectorlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEintgR_Dictionary();
   static void *new_vectorlEintgR(void *p = 0);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static ROOT::TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "/t2k/Software/v12r25/ROOT/v5r34p34n00/Linux-x86_64/lib/root/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<int>), ::ROOT::DefineBehavior(ptr, ptr),
                  0, &vectorlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo( ::ROOT::TCollectionProxyInfo::Generate( ::ROOT::TCollectionProxyInfo::Pushback< vector<int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEintgR_Dictionary() {
      ::ROOTDict::GenerateInitInstanceLocal((const vector<int>*)0x0)->GetClass();
   }

} // end of namespace ROOTDict

namespace ROOTDict {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOTDict for class vector<int>

/********************************************************
* /home/t2k/aspeers/Highland_Installs/HighLAND_2.89/psycheEventModel_3.47/Linux-CentOS_7-gcc_4.8-x86_64/dict/G_BaseDataClasses.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableG_BaseDataClasses();

extern "C" void G__set_cpp_environmentG_BaseDataClasses() {
  G__cpp_reset_tagtableG_BaseDataClasses();
}
#include <new>
extern "C" int G__cpp_dllrevG_BaseDataClasses() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* AnaTrueParticleB */
static int G__G_BaseDataClasses_542_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaTrueParticleB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrueParticleB[n];
     } else {
       p = new((void*) gvp) AnaTrueParticleB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrueParticleB;
     } else {
       p = new((void*) gvp) AnaTrueParticleB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_542_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const AnaTrueParticleB*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_542_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) AnaTrueParticleB::CompareMomentum((AnaTrueObjectC*) G__int(libp->para[0]), (AnaTrueObjectC*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaTrueParticleB G__TAnaTrueParticleB;
static int G__G_BaseDataClasses_542_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaTrueParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaTrueParticleB*) (soff+(sizeof(AnaTrueParticleB)*i)))->~G__TAnaTrueParticleB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaTrueParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaTrueParticleB*) (soff))->~G__TAnaTrueParticleB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_542_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaTrueParticleB* dest = (AnaTrueParticleB*) G__getstructoffset();
   *dest = *(AnaTrueParticleB*) libp->para[0].ref;
   const AnaTrueParticleB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaDetCrossingB */
static int G__G_BaseDataClasses_543_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaDetCrossingB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaDetCrossingB[n];
     } else {
       p = new((void*) gvp) AnaDetCrossingB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaDetCrossingB;
     } else {
       p = new((void*) gvp) AnaDetCrossingB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_543_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaDetCrossingB*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaDetCrossingB G__TAnaDetCrossingB;
static int G__G_BaseDataClasses_543_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaDetCrossingB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaDetCrossingB*) (soff+(sizeof(AnaDetCrossingB)*i)))->~G__TAnaDetCrossingB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaDetCrossingB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaDetCrossingB*) (soff))->~G__TAnaDetCrossingB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_543_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaDetCrossingB* dest = (AnaDetCrossingB*) G__getstructoffset();
   *dest = *(AnaDetCrossingB*) libp->para[0].ref;
   const AnaDetCrossingB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaTrueVertexB */
static int G__G_BaseDataClasses_544_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaTrueVertexB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrueVertexB[n];
     } else {
       p = new((void*) gvp) AnaTrueVertexB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrueVertexB;
     } else {
       p = new((void*) gvp) AnaTrueVertexB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_544_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const AnaTrueVertexB*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaTrueVertexB G__TAnaTrueVertexB;
static int G__G_BaseDataClasses_544_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaTrueVertexB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaTrueVertexB*) (soff+(sizeof(AnaTrueVertexB)*i)))->~G__TAnaTrueVertexB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaTrueVertexB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaTrueVertexB*) (soff))->~G__TAnaTrueVertexB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_544_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaTrueVertexB* dest = (AnaTrueVertexB*) G__getstructoffset();
   *dest = *(AnaTrueVertexB*) libp->para[0].ref;
   const AnaTrueVertexB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaToF */
static int G__G_BaseDataClasses_552_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaToF* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaToF[n];
     } else {
       p = new((void*) gvp) AnaToF[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaToF;
     } else {
       p = new((void*) gvp) AnaToF;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_552_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const AnaToF& obj = ((AnaToF*) G__getstructoffset())->operator=(*(AnaToF*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_552_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const AnaToF*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G_BaseDataClasses_552_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   AnaToF* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new AnaToF(*(AnaToF*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaToF G__TAnaToF;
static int G__G_BaseDataClasses_552_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaToF*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaToF*) (soff+(sizeof(AnaToF)*i)))->~G__TAnaToF();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaToF*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaToF*) (soff))->~G__TAnaToF();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaParticleB */
static int G__G_BaseDataClasses_554_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaParticleB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaParticleB[n];
     } else {
       p = new((void*) gvp) AnaParticleB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaParticleB;
     } else {
       p = new((void*) gvp) AnaParticleB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_554_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) AnaParticleB::CompareNHits((AnaRecObjectC*) G__int(libp->para[0]), (AnaRecObjectC*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_554_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const AnaParticleB*) G__getstructoffset())->GetTrueParticle());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaParticleB G__TAnaParticleB;
static int G__G_BaseDataClasses_554_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaParticleB*) (soff+(sizeof(AnaParticleB)*i)))->~G__TAnaParticleB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaParticleB*) (soff))->~G__TAnaParticleB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaParticleMomE */
static int G__G_BaseDataClasses_555_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaParticleMomE* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaParticleMomE[n];
     } else {
       p = new((void*) gvp) AnaParticleMomE[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaParticleMomE;
     } else {
       p = new((void*) gvp) AnaParticleMomE;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_555_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const AnaParticleMomE*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaParticleMomE G__TAnaParticleMomE;
static int G__G_BaseDataClasses_555_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaParticleMomE*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaParticleMomE*) (soff+(sizeof(AnaParticleMomE)*i)))->~G__TAnaParticleMomE();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaParticleMomE*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaParticleMomE*) (soff))->~G__TAnaParticleMomE();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_555_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaParticleMomE* dest = (AnaParticleMomE*) G__getstructoffset();
   *dest = *(AnaParticleMomE*) libp->para[0].ref;
   const AnaParticleMomE& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaParticleMomB */
static int G__G_BaseDataClasses_556_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaParticleMomB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaParticleMomB[n];
     } else {
       p = new((void*) gvp) AnaParticleMomB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaParticleMomB;
     } else {
       p = new((void*) gvp) AnaParticleMomB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_556_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) AnaParticleMomB::CompareMomentum((AnaRecObjectC*) G__int(libp->para[0]), (AnaRecObjectC*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaParticleMomB G__TAnaParticleMomB;
static int G__G_BaseDataClasses_556_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaParticleMomB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaParticleMomB*) (soff+(sizeof(AnaParticleMomB)*i)))->~G__TAnaParticleMomB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaParticleMomB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaParticleMomB*) (soff))->~G__TAnaParticleMomB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaTPCParticleB */
static int G__G_BaseDataClasses_557_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaTPCParticleB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTPCParticleB[n];
     } else {
       p = new((void*) gvp) AnaTPCParticleB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTPCParticleB;
     } else {
       p = new((void*) gvp) AnaTPCParticleB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaTPCParticleB G__TAnaTPCParticleB;
static int G__G_BaseDataClasses_557_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaTPCParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaTPCParticleB*) (soff+(sizeof(AnaTPCParticleB)*i)))->~G__TAnaTPCParticleB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaTPCParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaTPCParticleB*) (soff))->~G__TAnaTPCParticleB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaFGDParticleB */
static int G__G_BaseDataClasses_558_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaFGDParticleB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaFGDParticleB[n];
     } else {
       p = new((void*) gvp) AnaFGDParticleB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaFGDParticleB;
     } else {
       p = new((void*) gvp) AnaFGDParticleB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaFGDParticleB G__TAnaFGDParticleB;
static int G__G_BaseDataClasses_558_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaFGDParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaFGDParticleB*) (soff+(sizeof(AnaFGDParticleB)*i)))->~G__TAnaFGDParticleB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaFGDParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaFGDParticleB*) (soff))->~G__TAnaFGDParticleB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaECALParticleB */
static int G__G_BaseDataClasses_559_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaECALParticleB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaECALParticleB[n];
     } else {
       p = new((void*) gvp) AnaECALParticleB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaECALParticleB;
     } else {
       p = new((void*) gvp) AnaECALParticleB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaECALParticleB G__TAnaECALParticleB;
static int G__G_BaseDataClasses_559_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaECALParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaECALParticleB*) (soff+(sizeof(AnaECALParticleB)*i)))->~G__TAnaECALParticleB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaECALParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaECALParticleB*) (soff))->~G__TAnaECALParticleB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaSMRDParticleB */
static int G__G_BaseDataClasses_560_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaSMRDParticleB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaSMRDParticleB[n];
     } else {
       p = new((void*) gvp) AnaSMRDParticleB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaSMRDParticleB;
     } else {
       p = new((void*) gvp) AnaSMRDParticleB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaSMRDParticleB G__TAnaSMRDParticleB;
static int G__G_BaseDataClasses_560_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaSMRDParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaSMRDParticleB*) (soff+(sizeof(AnaSMRDParticleB)*i)))->~G__TAnaSMRDParticleB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaSMRDParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaSMRDParticleB*) (soff))->~G__TAnaSMRDParticleB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaP0DParticleB */
static int G__G_BaseDataClasses_561_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaP0DParticleB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaP0DParticleB[n];
     } else {
       p = new((void*) gvp) AnaP0DParticleB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaP0DParticleB;
     } else {
       p = new((void*) gvp) AnaP0DParticleB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaP0DParticleB G__TAnaP0DParticleB;
static int G__G_BaseDataClasses_561_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaP0DParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaP0DParticleB*) (soff+(sizeof(AnaP0DParticleB)*i)))->~G__TAnaP0DParticleB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaP0DParticleB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaP0DParticleB*) (soff))->~G__TAnaP0DParticleB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaTrackerTrackB */
static int G__G_BaseDataClasses_562_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaTrackerTrackB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrackerTrackB[n];
     } else {
       p = new((void*) gvp) AnaTrackerTrackB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrackerTrackB;
     } else {
       p = new((void*) gvp) AnaTrackerTrackB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaTrackerTrackB G__TAnaTrackerTrackB;
static int G__G_BaseDataClasses_562_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaTrackerTrackB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaTrackerTrackB*) (soff+(sizeof(AnaTrackerTrackB)*i)))->~G__TAnaTrackerTrackB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaTrackerTrackB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaTrackerTrackB*) (soff))->~G__TAnaTrackerTrackB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaRecTrueMatchB */
static int G__G_BaseDataClasses_563_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaRecTrueMatchB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaRecTrueMatchB[n];
     } else {
       p = new((void*) gvp) AnaRecTrueMatchB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaRecTrueMatchB;
     } else {
       p = new((void*) gvp) AnaRecTrueMatchB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_563_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaRecTrueMatchB*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__G_BaseDataClasses_563_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   AnaRecTrueMatchB* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new AnaRecTrueMatchB(*(AnaRecTrueMatchB*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaRecTrueMatchB G__TAnaRecTrueMatchB;
static int G__G_BaseDataClasses_563_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaRecTrueMatchB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaRecTrueMatchB*) (soff+(sizeof(AnaRecTrueMatchB)*i)))->~G__TAnaRecTrueMatchB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaRecTrueMatchB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaRecTrueMatchB*) (soff))->~G__TAnaRecTrueMatchB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_563_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaRecTrueMatchB* dest = (AnaRecTrueMatchB*) G__getstructoffset();
   *dest = *(AnaRecTrueMatchB*) libp->para[0].ref;
   const AnaRecTrueMatchB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaTrackB */
static int G__G_BaseDataClasses_564_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaTrackB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrackB[n];
     } else {
       p = new((void*) gvp) AnaTrackB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaTrackB;
     } else {
       p = new((void*) gvp) AnaTrackB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_564_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const AnaTrackB*) G__getstructoffset())->GetOriginalTrack());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_564_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) AnaTrackB::CompareMuonRangeMomentum((AnaRecObjectC*) G__int(libp->para[0]), (AnaRecObjectC*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_564_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) AnaTrackB::CompareProtonRangeMomentum((AnaRecObjectC*) G__int(libp->para[0]), (AnaRecObjectC*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_564_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) AnaTrackB::ComparePionRangeMomentum((AnaRecObjectC*) G__int(libp->para[0]), (AnaRecObjectC*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_564_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((AnaTrackB*) G__getstructoffset())->Flip();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_564_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((AnaTrackB*) G__getstructoffset())->UnFlip();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_564_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((AnaTrackB*) G__getstructoffset())->GetIsFlipped());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaTrackB G__TAnaTrackB;
static int G__G_BaseDataClasses_564_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaTrackB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaTrackB*) (soff+(sizeof(AnaTrackB)*i)))->~G__TAnaTrackB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaTrackB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaTrackB*) (soff))->~G__TAnaTrackB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaVertexB */
static int G__G_BaseDataClasses_585_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaVertexB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaVertexB[n];
     } else {
       p = new((void*) gvp) AnaVertexB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaVertexB;
     } else {
       p = new((void*) gvp) AnaVertexB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const AnaVertexB*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) AnaVertexB::ComparePrimaryIndex((AnaRecObjectC*) G__int(libp->para[0]), (AnaRecObjectC*) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 105, (long) ((AnaVertexB*) G__getstructoffset())->GetTrueVertices((AnaTrueVertexB**) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 85, (long) ((AnaVertexB*) G__getstructoffset())->GetMainTrueVertex((bool) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 85, (long) ((AnaVertexB*) G__getstructoffset())->GetMainTrueVertex());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((AnaVertexB*) G__getstructoffset())->GetMainTrueVertexCleanliness());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((AnaVertexB*) G__getstructoffset())->GetMainTrueVertexCompleteness());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((AnaVertexB*) G__getstructoffset())->GetTrueVertexCleanliness(*(AnaTrueVertexB*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_585_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((AnaVertexB*) G__getstructoffset())->GetTrueVertexCompleteness(*(AnaTrueVertexB*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaVertexB G__TAnaVertexB;
static int G__G_BaseDataClasses_585_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaVertexB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaVertexB*) (soff+(sizeof(AnaVertexB)*i)))->~G__TAnaVertexB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaVertexB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaVertexB*) (soff))->~G__TAnaVertexB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaBeamB */
static int G__G_BaseDataClasses_591_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaBeamB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaBeamB[n];
     } else {
       p = new((void*) gvp) AnaBeamB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaBeamB;
     } else {
       p = new((void*) gvp) AnaBeamB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_591_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaBeamB*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaBeamB G__TAnaBeamB;
static int G__G_BaseDataClasses_591_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaBeamB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaBeamB*) (soff+(sizeof(AnaBeamB)*i)))->~G__TAnaBeamB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaBeamB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaBeamB*) (soff))->~G__TAnaBeamB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_591_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaBeamB* dest = (AnaBeamB*) G__getstructoffset();
   *dest = *(AnaBeamB*) libp->para[0].ref;
   const AnaBeamB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaDataQualityB */
static int G__G_BaseDataClasses_592_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaDataQualityB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaDataQualityB[n];
     } else {
       p = new((void*) gvp) AnaDataQualityB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaDataQualityB;
     } else {
       p = new((void*) gvp) AnaDataQualityB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_592_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaDataQualityB*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaDataQualityB G__TAnaDataQualityB;
static int G__G_BaseDataClasses_592_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaDataQualityB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaDataQualityB*) (soff+(sizeof(AnaDataQualityB)*i)))->~G__TAnaDataQualityB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaDataQualityB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaDataQualityB*) (soff))->~G__TAnaDataQualityB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_592_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaDataQualityB* dest = (AnaDataQualityB*) G__getstructoffset();
   *dest = *(AnaDataQualityB*) libp->para[0].ref;
   const AnaDataQualityB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaDelayedClustersB */
static int G__G_BaseDataClasses_593_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaDelayedClustersB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaDelayedClustersB[n];
     } else {
       p = new((void*) gvp) AnaDelayedClustersB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaDelayedClustersB;
     } else {
       p = new((void*) gvp) AnaDelayedClustersB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_593_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaDelayedClustersB*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaDelayedClustersB G__TAnaDelayedClustersB;
static int G__G_BaseDataClasses_593_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaDelayedClustersB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaDelayedClustersB*) (soff+(sizeof(AnaDelayedClustersB)*i)))->~G__TAnaDelayedClustersB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaDelayedClustersB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaDelayedClustersB*) (soff))->~G__TAnaDelayedClustersB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_593_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaDelayedClustersB* dest = (AnaDelayedClustersB*) G__getstructoffset();
   *dest = *(AnaDelayedClustersB*) libp->para[0].ref;
   const AnaDelayedClustersB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaBunchB */
static int G__G_BaseDataClasses_594_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaBunchB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaBunchB[n];
     } else {
       p = new((void*) gvp) AnaBunchB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaBunchB;
     } else {
       p = new((void*) gvp) AnaBunchB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_594_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaBunchB*) G__getstructoffset())->GetPrimaryVertex());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_594_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const AnaBunchB*) G__getstructoffset())->IsEmpty());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaBunchB G__TAnaBunchB;
static int G__G_BaseDataClasses_594_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaBunchB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaBunchB*) (soff+(sizeof(AnaBunchB)*i)))->~G__TAnaBunchB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaBunchB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaBunchB*) (soff))->~G__TAnaBunchB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_594_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaBunchB* dest = (AnaBunchB*) G__getstructoffset();
   *dest = *(AnaBunchB*) libp->para[0].ref;
   const AnaBunchB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaFgdTimeBinB */
static int G__G_BaseDataClasses_603_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaFgdTimeBinB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaFgdTimeBinB[n];
     } else {
       p = new((void*) gvp) AnaFgdTimeBinB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaFgdTimeBinB;
     } else {
       p = new((void*) gvp) AnaFgdTimeBinB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_603_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaFgdTimeBinB*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_603_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const AnaFgdTimeBinB*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaFgdTimeBinB G__TAnaFgdTimeBinB;
static int G__G_BaseDataClasses_603_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaFgdTimeBinB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaFgdTimeBinB*) (soff+(sizeof(AnaFgdTimeBinB)*i)))->~G__TAnaFgdTimeBinB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaFgdTimeBinB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaFgdTimeBinB*) (soff))->~G__TAnaFgdTimeBinB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_603_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaFgdTimeBinB* dest = (AnaFgdTimeBinB*) G__getstructoffset();
   *dest = *(AnaFgdTimeBinB*) libp->para[0].ref;
   const AnaFgdTimeBinB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaEventInfoB */
static int G__G_BaseDataClasses_604_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaEventInfoB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaEventInfoB[n];
     } else {
       p = new((void*) gvp) AnaEventInfoB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaEventInfoB;
     } else {
       p = new((void*) gvp) AnaEventInfoB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_604_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaEventInfoB*) G__getstructoffset())->Clone());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_604_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const AnaEventInfoB*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_604_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const AnaEventInfoB*) G__getstructoffset())->GetIsMC());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_604_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const AnaEventInfoB*) G__getstructoffset())->GetIsSandMC());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_604_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((AnaEventInfoB*) G__getstructoffset())->SetIsSandMC();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaEventInfoB G__TAnaEventInfoB;
static int G__G_BaseDataClasses_604_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaEventInfoB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaEventInfoB*) (soff+(sizeof(AnaEventInfoB)*i)))->~G__TAnaEventInfoB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaEventInfoB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaEventInfoB*) (soff))->~G__TAnaEventInfoB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_604_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaEventInfoB* dest = (AnaEventInfoB*) G__getstructoffset();
   *dest = *(AnaEventInfoB*) libp->para[0].ref;
   const AnaEventInfoB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaSpillB */
static int G__G_BaseDataClasses_605_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaSpillB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaSpillB[n];
     } else {
       p = new((void*) gvp) AnaSpillB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaSpillB;
     } else {
       p = new((void*) gvp) AnaSpillB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_605_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const AnaSpillB*) G__getstructoffset())->GetIsSandMC());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_605_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaSpillB*) G__getstructoffset())->GetTrueParticleByID((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_605_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaSpillB*) G__getstructoffset())->GetTrueVertexByID((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_605_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((AnaSpillB*) G__getstructoffset())->GetParticleByUniqueID((int) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaSpillB G__TAnaSpillB;
static int G__G_BaseDataClasses_605_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaSpillB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaSpillB*) (soff+(sizeof(AnaSpillB)*i)))->~G__TAnaSpillB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaSpillB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaSpillB*) (soff))->~G__TAnaSpillB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_605_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaSpillB* dest = (AnaSpillB*) G__getstructoffset();
   *dest = *(AnaSpillB*) libp->para[0].ref;
   const AnaSpillB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* AnaEventB */
static int G__G_BaseDataClasses_619_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaEventB* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaEventB[n];
     } else {
       p = new((void*) gvp) AnaEventB[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new AnaEventB;
     } else {
       p = new((void*) gvp) AnaEventB;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_619_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaEventB* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new AnaEventB(*(AnaSpillB*) libp->para[0].ref, *(AnaBunchB*) libp->para[1].ref);
   } else {
     p = new((void*) gvp) AnaEventB(*(AnaSpillB*) libp->para[0].ref, *(AnaBunchB*) libp->para[1].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__G_BaseDataClasses_619_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const AnaEventB*) G__getstructoffset())->GetIsSandMC());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef AnaEventB G__TAnaEventB;
static int G__G_BaseDataClasses_619_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (AnaEventB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((AnaEventB*) (soff+(sizeof(AnaEventB)*i)))->~G__TAnaEventB();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (AnaEventB*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((AnaEventB*) (soff))->~G__TAnaEventB();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__G_BaseDataClasses_619_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   AnaEventB* dest = (AnaEventB*) G__getstructoffset();
   *dest = *(AnaEventB*) libp->para[0].ref;
   const AnaEventB& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* AnaTrueParticleB */

/* AnaDetCrossingB */

/* AnaTrueVertexB */

/* AnaToF */

/* AnaParticleB */

/* AnaParticleMomE */

/* AnaParticleMomB */

/* AnaTPCParticleB */

/* AnaFGDParticleB */

/* AnaECALParticleB */

/* AnaSMRDParticleB */

/* AnaP0DParticleB */

/* AnaTrackerTrackB */

/* AnaRecTrueMatchB */

/* AnaTrackB */

/* AnaVertexB */

/* AnaBeamB */

/* AnaDataQualityB */

/* AnaDelayedClustersB */

/* AnaBunchB */

/* AnaFgdTimeBinB */

/* AnaEventInfoB */

/* AnaSpillB */

/* AnaEventB */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncG_BaseDataClasses {
 public:
  G__Sizep2memfuncG_BaseDataClasses(): p(&G__Sizep2memfuncG_BaseDataClasses::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncG_BaseDataClasses::*p)();
};

size_t G__get_sizep2memfuncG_BaseDataClasses()
{
  G__Sizep2memfuncG_BaseDataClasses a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceG_BaseDataClasses() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB))) {
     AnaTrueParticleB *G__Lderived;
     G__Lderived=(AnaTrueParticleB*)0x1000;
     {
       AnaTrueObjectC *G__Lpbase=(AnaTrueObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueObjectC),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB))) {
     AnaTrueVertexB *G__Lderived;
     G__Lderived=(AnaTrueVertexB*)0x1000;
     {
       AnaTrueObjectC *G__Lpbase=(AnaTrueObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueObjectC),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB))) {
     AnaParticleB *G__Lderived;
     G__Lderived=(AnaParticleB*)0x1000;
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB))) {
     AnaParticleMomB *G__Lderived;
     G__Lderived=(AnaParticleMomB*)0x1000;
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       AnaParticleMomE *G__Lpbase=(AnaParticleMomE*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB))) {
     AnaTPCParticleB *G__Lderived;
     G__Lderived=(AnaTPCParticleB*)0x1000;
     {
       AnaParticleMomB *G__Lpbase=(AnaParticleMomB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       AnaParticleMomE *G__Lpbase=(AnaParticleMomE*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB))) {
     AnaFGDParticleB *G__Lderived;
     G__Lderived=(AnaFGDParticleB*)0x1000;
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB))) {
     AnaECALParticleB *G__Lderived;
     G__Lderived=(AnaECALParticleB*)0x1000;
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB))) {
     AnaSMRDParticleB *G__Lderived;
     G__Lderived=(AnaSMRDParticleB*)0x1000;
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB))) {
     AnaP0DParticleB *G__Lderived;
     G__Lderived=(AnaP0DParticleB*)0x1000;
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB))) {
     AnaTrackerTrackB *G__Lderived;
     G__Lderived=(AnaTrackerTrackB*)0x1000;
     {
       AnaParticleMomB *G__Lpbase=(AnaParticleMomB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       AnaParticleMomE *G__Lpbase=(AnaParticleMomE*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB))) {
     AnaTrackB *G__Lderived;
     G__Lderived=(AnaTrackB*)0x1000;
     {
       AnaParticleMomB *G__Lpbase=(AnaParticleMomB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
     {
       AnaParticleB *G__Lpbase=(AnaParticleB*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
     {
       AnaParticleMomE *G__Lpbase=(AnaParticleMomE*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE),(long)G__Lpbase-(long)G__Lderived,1,0);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB))) {
     AnaVertexB *G__Lderived;
     G__Lderived=(AnaVertexB*)0x1000;
     {
       AnaRecObjectC *G__Lpbase=(AnaRecObjectC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecObjectC),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB))) {
     AnaBunchB *G__Lderived;
     G__Lderived=(AnaBunchB*)0x1000;
     {
       AnaBunchC *G__Lpbase=(AnaBunchC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchC),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB))) {
     AnaSpillB *G__Lderived;
     G__Lderived=(AnaSpillB*)0x1000;
     {
       AnaSpillC *G__Lpbase=(AnaSpillC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillC),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB))) {
     AnaEventB *G__Lderived;
     G__Lderived=(AnaEventB*)0x1000;
     {
       AnaEventC *G__Lpbase=(AnaEventC*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB),G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventC),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableG_BaseDataClasses() {

   /* Setting up typedef entry */
   G__search_typename2("Float_t",102,-1,0,-1);
   G__setnewtype(-1,"Float 4 bytes (float)",0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTBaselEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTBase<Double_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTBaselEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TVectorTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TVectorT<Double_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TVectorTlEdoublegR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixT<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow_const<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn_const<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTColumn_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag_const<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat_const<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTFlat_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub_const<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTSub_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow_const<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTSparseRow_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag_const<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTSparseDiag_constlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTRow<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTColumn<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTColumnlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTDiag<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTFlat<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTFlatlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSub<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTSublEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseRow<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTSparseRowlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TMatrixTSparseDiag<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TMatrixTSparseDiaglEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementActionT<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TElementActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("TElementPosActionT<Float_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_TElementPosActionTlEfloatgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaBunchC*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<std::string,SampleEnum>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_maplEstringcOSampleIdcLcLSampleEnumcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOSampleIdcLcLSampleEnumgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,SampleEnum>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_maplEstringcOSampleIdcLcLSampleEnumcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOSampleIdcLcLSampleEnumgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,SampleId::SampleEnum>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_maplEstringcOSampleIdcLcLSampleEnumcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOSampleIdcLcLSampleEnumgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<string,SampleId::SampleEnum,less<string> >",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_maplEstringcOSampleIdcLcLSampleEnumcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOSampleIdcLcLSampleEnumgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("set<std::string>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_setlEstringcOlesslEstringgRcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("set<string>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_setlEstringcOlesslEstringgRcOallocatorlEstringgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<Int_t>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<int>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaDetCrossingB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaTPCParticleB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaFGDParticleB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaECALParticleB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaSMRDParticleB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaP0DParticleB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<std::pair<AnaTrueVertexB*,AnaRecTrueMatchB> >",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<AnaTrueVertexB*,AnaRecTrueMatchB> >",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<pair<AnaTrueVertexB*,AnaRecTrueMatchB> >",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaVertexB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaParticleB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaTrueVertexB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaTrueParticleB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<AnaFgdTimeBinB*>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* AnaTrueParticleB */
static void G__setup_memvarAnaTrueParticleB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB));
   { AnaTrueParticleB *p; p=(AnaTrueParticleB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->PDG)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"PDG=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PrimaryID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"PrimaryID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ParentID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"ParentID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ParentPDG)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"ParentPDG=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GParentID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"GParentID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GParentPDG)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"GParentPDG=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Position)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Position[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PositionEnd)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"PositionEnd[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Direction)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Direction[3]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Momentum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Momentum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Charge)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Charge=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->VertexID)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"VertexID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrueVertex)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB),-1,-1,1,"TrueVertex=",0,"!");
   G__memvar_setup((void*)((long)(&p->DetCrossings)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB),-1,-1,1,"DetCrossings=",0,"!");
   G__memvar_setup((void*)((long)(&p->nDetCrossings)-(long)(p)),105,0,0,-1,-1,-1,1,"nDetCrossings=",0,"!");
   G__memvar_setup((void*)((long)(&p->DetCrossingsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgR),G__defined_typename("vector<AnaDetCrossingB*>"),-1,1,"DetCrossingsVect=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->IsTruePrimaryPi0DecayPhoton)-(long)(p)),103,0,0,-1,-1,-1,1,"IsTruePrimaryPi0DecayPhoton=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->IsTruePrimaryPi0DecayPhotonChild)-(long)(p)),103,0,0,-1,-1,-1,1,"IsTruePrimaryPi0DecayPhotonChild=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaDetCrossingB */
static void G__setup_memvarAnaDetCrossingB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB));
   { AnaDetCrossingB *p; p=(AnaDetCrossingB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EntrancePosition)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"EntrancePosition[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ExitPosition)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"ExitPosition[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EntranceMomentum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"EntranceMomentum[3]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ExitMomentum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"ExitMomentum[3]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->InActive)-(long)(p)),103,0,0,-1,-1,-1,1,"InActive=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Detector)-(long)(p)),107,0,0,-1,-1,-1,1,"Detector=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ExitOK)-(long)(p)),103,0,0,-1,-1,-1,1,"ExitOK=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EntranceOK)-(long)(p)),103,0,0,-1,-1,-1,1,"EntranceOK=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaTrueVertexB */
static void G__setup_memvarAnaTrueVertexB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB));
   { AnaTrueVertexB *p; p=(AnaTrueVertexB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NuPDG)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NuPDG=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NuEnergy)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"NuEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Position)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Position[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Bunch)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Bunch=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrueParticles)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB),-1,-1,1,"TrueParticles=",0,"!");
   G__memvar_setup((void*)((long)(&p->nTrueParticles)-(long)(p)),105,0,0,-1,-1,-1,1,"nTrueParticles=",0,"!");
   G__memvar_setup((void*)((long)(&p->TrueParticlesIDsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<Int_t>"),-1,1,"TrueParticlesIDsVect=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Detector)-(long)(p)),107,0,0,-1,-1,-1,1,"Detector=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaToF */
static void G__setup_memvarAnaToF(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF));
   { AnaToF *p; p=(AnaToF*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag),-1,-2,1,G__FastAllocString(2048).Format("kNotValid=%lldLL",(long long)AnaToF::kNotValid).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag),-1,-2,1,G__FastAllocString(2048).Format("kValid=%lldLL",(long long)AnaToF::kValid).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag),-1,-2,1,G__FastAllocString(2048).Format("kValidNoSlip=%lldLL",(long long)AnaToF::kValidNoSlip).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag),-1,-2,1,G__FastAllocString(2048).Format("kValidUpSlip=%lldLL",(long long)AnaToF::kValidUpSlip).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag),-1,-2,1,G__FastAllocString(2048).Format("kValidDownSlip=%lldLL",(long long)AnaToF::kValidDownSlip).data(),0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->FGD1_FGD2)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"FGD1_FGD2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Flag_FGD1_FGD2)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Flag_FGD1_FGD2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->P0D_FGD1)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"P0D_FGD1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Flag_P0D_FGD1)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Flag_P0D_FGD1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DSECal_FGD1)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"DSECal_FGD1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Flag_DSECal_FGD1)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Flag_DSECal_FGD1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ECal_FGD1)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"ECal_FGD1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Flag_ECal_FGD1)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Flag_ECal_FGD1=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ECal_FGD2)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"ECal_FGD2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Flag_ECal_FGD2)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Flag_ECal_FGD2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DSECal_FGD2)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"DSECal_FGD2=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Flag_DSECal_FGD2)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Flag_DSECal_FGD2=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaParticleB */
static void G__setup_memvarAnaParticleB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB));
   { AnaParticleB *p; p=(AnaParticleB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->NHits)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NHits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NNodes)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NNodes=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DirectionStart)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"DirectionStart[3]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DirectionEnd)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"DirectionEnd[3]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PositionStart)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"PositionStart[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PositionEnd)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"PositionEnd[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Original)-(long)(p)),85,0,1,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),-1,-1,1,"Original=",0,"!");
   }
   G__tag_memvar_reset();
}


   /* AnaParticleMomE */
static void G__setup_memvarAnaParticleMomE(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE));
   { AnaParticleMomE *p; p=(AnaParticleMomE*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Charge)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Charge=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Momentum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Momentum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MomentumEnd)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"MomentumEnd=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaParticleMomB */
static void G__setup_memvarAnaParticleMomB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB));
   { AnaParticleMomB *p; p=(AnaParticleMomB*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* AnaTPCParticleB */
static void G__setup_memvarAnaTPCParticleB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB));
   { AnaTPCParticleB *p; p=(AnaTPCParticleB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->MomentumError)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"MomentumError=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RefitMomentum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"RefitMomentum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EFieldRefitMomentum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"EFieldRefitMomentum=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxMeas)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxMeas=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxexpMuon)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxexpMuon=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxexpEle)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxexpEle=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxexpPion)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxexpPion=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxexpProton)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxexpProton=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxSigmaMuon)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxSigmaMuon=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxSigmaEle)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxSigmaEle=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxSigmaPion)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxSigmaPion=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->dEdxSigmaProton)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"dEdxSigmaProton=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaFGDParticleB */
static void G__setup_memvarAnaFGDParticleB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB));
   { AnaFGDParticleB *p; p=(AnaFGDParticleB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->X)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"X=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->E)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"E=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Pullmu)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Pullmu=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Pullp)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Pullp=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Pullpi)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Pullpi=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Pullno)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Pullno=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Pulle)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Pulle=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Containment)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Containment=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaECALParticleB */
static void G__setup_memvarAnaECALParticleB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB));
   { AnaECALParticleB *p; p=(AnaECALParticleB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Clustering3DSeedType)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Clustering3DSeedType=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ClusteringAdded3DClusterHits)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"ClusteringAdded3DClusterHits=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PIDQuality)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"PIDQuality=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PIDMipEm)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"PIDMipEm=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PIDMipPion)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"PIDMipPion=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PIDEmHip)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"PIDEmHip=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Length)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Length=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EMEnergy)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"EMEnergy=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EDeposit)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"EDeposit=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->IsShowerLike)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"IsShowerLike=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->AvgTime)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"AvgTime=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MostUpStreamLayerHit)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"MostUpStreamLayerHit=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ShowerPosition)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"ShowerPosition[3]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaSMRDParticleB */
static void G__setup_memvarAnaSMRDParticleB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB));
   { AnaSMRDParticleB *p; p=(AnaSMRDParticleB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->AvgTime)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"AvgTime=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaP0DParticleB */
static void G__setup_memvarAnaP0DParticleB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB));
   { AnaP0DParticleB *p; p=(AnaP0DParticleB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Length)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Length=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ELoss)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"ELoss=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaTrackerTrackB */
static void G__setup_memvarAnaTrackerTrackB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB));
   { AnaTrackerTrackB *p; p=(AnaTrackerTrackB*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* AnaRecTrueMatchB */
static void G__setup_memvarAnaRecTrueMatchB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB));
   { AnaRecTrueMatchB *p; p=(AnaRecTrueMatchB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Cleanliness)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Cleanliness=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Completeness)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Completeness=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaTrackB */
static void G__setup_memvarAnaTrackB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB));
   { AnaTrackB *p; p=(AnaTrackB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,2,"IsFlipped=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Index)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Index=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RangeMomentumMuon)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"RangeMomentumMuon=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RangeMomentumProton)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"RangeMomentumProton=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RangeMomentumPion)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"RangeMomentumPion=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MomentumFlip)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"MomentumFlip=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TPCQualityCut)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"TPCQualityCut=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ToF)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF),-1,-1,1,"ToF=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TPCSegments)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB),-1,-1,1,"TPCSegments[3]=",0,"!");
   G__memvar_setup((void*)((long)(&p->nTPCSegments)-(long)(p)),105,0,0,-1,-1,-1,1,"nTPCSegments=",0,"!");
   G__memvar_setup((void*)((long)(&p->FGDSegments)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB),-1,-1,1,"FGDSegments[2]=",0,"!");
   G__memvar_setup((void*)((long)(&p->nFGDSegments)-(long)(p)),105,0,0,-1,-1,-1,1,"nFGDSegments=",0,"!");
   G__memvar_setup((void*)((long)(&p->ECALSegments)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB),-1,-1,1,"ECALSegments[3]=",0,"!");
   G__memvar_setup((void*)((long)(&p->nECALSegments)-(long)(p)),105,0,0,-1,-1,-1,1,"nECALSegments=",0,"!");
   G__memvar_setup((void*)((long)(&p->SMRDSegments)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB),-1,-1,1,"SMRDSegments[4]=",0,"!");
   G__memvar_setup((void*)((long)(&p->nSMRDSegments)-(long)(p)),105,0,0,-1,-1,-1,1,"nSMRDSegments=",0,"!");
   G__memvar_setup((void*)((long)(&p->P0DSegments)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB),-1,-1,1,"P0DSegments[1]=",0,"!");
   G__memvar_setup((void*)((long)(&p->nP0DSegments)-(long)(p)),105,0,0,-1,-1,-1,1,"nP0DSegments=",0,"!");
   G__memvar_setup((void*)((long)(&p->TPCSegmentsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgR),G__defined_typename("vector<AnaTPCParticleB*>"),-1,1,"TPCSegmentsVect=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->FGDSegmentsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgR),G__defined_typename("vector<AnaFGDParticleB*>"),-1,1,"FGDSegmentsVect=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->ECALSegmentsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgR),G__defined_typename("vector<AnaECALParticleB*>"),-1,1,"ECALSegmentsVect=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SMRDSegmentsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgR),G__defined_typename("vector<AnaSMRDParticleB*>"),-1,1,"SMRDSegmentsVect=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->P0DSegmentsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgR),G__defined_typename("vector<AnaP0DParticleB*>"),-1,1,"P0DSegmentsVect=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaVertexB */
static void G__setup_memvarAnaVertexB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB));
   { AnaVertexB *p; p=(AnaVertexB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Bunch)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Bunch=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->PrimaryIndex)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"PrimaryIndex=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Position)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"Position[4]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Particles)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),-1,-1,1,"Particles=",0,"!");
   G__memvar_setup((void*)((long)(&p->nParticles)-(long)(p)),105,0,0,-1,-1,-1,1,"nParticles=",0,"!");
   G__memvar_setup((void*)((long)(&p->ParticlesIDsVect)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR),G__defined_typename("vector<Int_t>"),-1,1,"ParticlesIDsVect=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrueVertex)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB),-1,-1,1,"TrueVertex=",0,"!");
   G__memvar_setup((void*)((long)(&p->TrueVerticesMatch)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR),G__defined_typename("vector<std::pair<AnaTrueVertexB*,AnaRecTrueMatchB> >"),-1,1,"TrueVerticesMatch=",0,"!");
   G__memvar_setup((void*)((long)(&p->Original)-(long)(p)),85,0,1,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB),-1,-1,1,"Original=",0,"!");
   }
   G__tag_memvar_reset();
}


   /* AnaBeamB */
static void G__setup_memvarAnaBeamB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB));
   { AnaBeamB *p; p=(AnaBeamB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GoodSpill)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"GoodSpill=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->POTSincePreviousSavedSpill)-(long)(p)),100,0,0,-1,G__defined_typename("Double_t"),-1,1,"POTSincePreviousSavedSpill=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SpillsSincePreviousSavedSpill)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"SpillsSincePreviousSavedSpill=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaDataQualityB */
static void G__setup_memvarAnaDataQualityB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB));
   { AnaDataQualityB *p; p=(AnaDataQualityB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GoodDaq)-(long)(p)),103,0,0,-1,-1,-1,1,"GoodDaq=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->GoodTimeDaq)-(long)(p)),103,0,0,-1,-1,-1,1,"GoodTimeDaq=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaDelayedClustersB */
static void G__setup_memvarAnaDelayedClustersB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB));
   { AnaDelayedClustersB *p; p=(AnaDelayedClustersB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MinTime)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"MinTime=",0,"Minimum time of a hit in the cluster");
   G__memvar_setup((void*)((long)(&p->MaxTime)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"MaxTime=",0,"Maximum time of a hit in the cluster");
   G__memvar_setup((void*)((long)(&p->NHits)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NHits=",0,"Number of hits in the cluster");
   G__memvar_setup((void*)((long)(&p->RawChargeSum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"RawChargeSum=",0,"Sum of the RawCharge of all hits");
   }
   G__tag_memvar_reset();
}


   /* AnaBunchB */
static void G__setup_memvarAnaBunchB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB));
   { AnaBunchB *p; p=(AnaBunchB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->Vertices)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgR),G__defined_typename("vector<AnaVertexB*>"),-1,1,"Vertices=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Particles)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgR),G__defined_typename("vector<AnaParticleB*>"),-1,1,"Particles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DelayedClusters)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB),-1,-1,1,"DelayedClusters=",0,"! ");
   G__memvar_setup((void*)((long)(&p->nDelayedClusters)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"nDelayedClusters=",0,"! ");
   }
   G__tag_memvar_reset();
}


   /* AnaFgdTimeBinB */
static void G__setup_memvarAnaFgdTimeBinB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB));
   { AnaFgdTimeBinB *p; p=(AnaFgdTimeBinB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->MinTime)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"MinTime=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NHits)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"NHits[2]=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->RawChargeSum)-(long)(p)),102,0,0,-1,G__defined_typename("Float_t"),-1,1,"RawChargeSum[2]=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaEventInfoB */
static void G__setup_memvarAnaEventInfoB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB));
   { AnaEventInfoB *p; p=(AnaEventInfoB*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Run)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Run=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->SubRun)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"SubRun=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Event)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Event=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->IsMC)-(long)(p)),103,0,0,-1,-1,-1,1,"IsMC=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->IsSand)-(long)(p)),103,0,0,-1,-1,-1,1,"IsSand=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaSpillB */
static void G__setup_memvarAnaSpillB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB));
   { AnaSpillB *p; p=(AnaSpillB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->GeomID)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"GeomID=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->EventInfo)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB),-1,-1,1,"EventInfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DataQuality)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB),-1,-1,1,"DataQuality=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Beam)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB),-1,-1,1,"Beam=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NTotalTrueVertices)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"NTotalTrueVertices=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->NTotalTrueParticles)-(long)(p)),104,0,0,-1,G__defined_typename("UInt_t"),-1,1,"NTotalTrueParticles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrueVertices)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgR),G__defined_typename("vector<AnaTrueVertexB*>"),-1,1,"TrueVertices=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrueParticles)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgR),G__defined_typename("vector<AnaTrueParticleB*>"),-1,1,"TrueParticles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->OutOfBunch)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB),-1,-1,1,"OutOfBunch=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->FgdTimeBins)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_vectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgR),G__defined_typename("vector<AnaFgdTimeBinB*>"),-1,1,"FgdTimeBins=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* AnaEventB */
static void G__setup_memvarAnaEventB(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB));
   { AnaEventB *p; p=(AnaEventB*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->EventInfo)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB),-1,-1,1,"EventInfo=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DataQuality)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB),-1,-1,1,"DataQuality=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Beam)-(long)(p)),85,0,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB),-1,-1,1,"Beam=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Bunch)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"Bunch=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Particles)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB),-1,-1,1,"Particles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nParticles)-(long)(p)),105,0,0,-1,-1,-1,1,"nParticles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->Vertices)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB),-1,-1,1,"Vertices=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nVertices)-(long)(p)),105,0,0,-1,-1,-1,1,"nVertices=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->FgdTimeBins)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB),-1,-1,1,"FgdTimeBins=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nFgdTimeBins)-(long)(p)),105,0,0,-1,-1,-1,1,"nFgdTimeBins=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->DelayedClusters)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB),-1,-1,1,"DelayedClusters=",0,"! ");
   G__memvar_setup((void*)((long)(&p->nDelayedClusters)-(long)(p)),105,0,0,-1,G__defined_typename("Int_t"),-1,1,"nDelayedClusters=",0,"! ");
   G__memvar_setup((void*)((long)(&p->TrueParticles)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB),-1,-1,1,"TrueParticles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nTrueParticles)-(long)(p)),105,0,0,-1,-1,-1,1,"nTrueParticles=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->TrueVertices)-(long)(p)),85,2,0,G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB),-1,-1,1,"TrueVertices=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->nTrueVertices)-(long)(p)),105,0,0,-1,-1,-1,1,"nTrueVertices=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarG_BaseDataClasses() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncAnaTrueParticleB(void) {
   /* AnaTrueParticleB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB));
   G__memfunc_setup("AnaTrueParticleB",1574,G__G_BaseDataClasses_542_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,G__G_BaseDataClasses_542_0_3, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AnaTrueParticleB",1574,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB), -1, 0, 1, 1, 2, 0, "u 'AnaTrueParticleB' - 11 - truePart", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CompareMomentum",1561,G__G_BaseDataClasses_542_0_5, 103, -1, -1, 0, 2, 3, 1, 0, 
"U 'AnaTrueObjectC' - 10 - p1 U 'AnaTrueObjectC' - 10 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const AnaTrueObjectC*, const AnaTrueObjectC*))(&AnaTrueParticleB::CompareMomentum) ), 0);
   // automatic destructor
   G__memfunc_setup("~AnaTrueParticleB", 1700, G__G_BaseDataClasses_542_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_542_0_7, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB), -1, 1, 1, 1, 1, 0, "u 'AnaTrueParticleB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaDetCrossingB(void) {
   /* AnaDetCrossingB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB));
   G__memfunc_setup("AnaDetCrossingB",1463,G__G_BaseDataClasses_543_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,G__G_BaseDataClasses_543_0_2, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaDetCrossingB",1463,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB), -1, 0, 1, 1, 2, 0, "u 'AnaDetCrossingB' - 11 - cross", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaDetCrossingB", 1589, G__G_BaseDataClasses_543_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_543_0_5, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDetCrossingB), -1, 1, 1, 1, 1, 0, "u 'AnaDetCrossingB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaTrueVertexB(void) {
   /* AnaTrueVertexB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB));
   G__memfunc_setup("AnaTrueVertexB",1392,G__G_BaseDataClasses_544_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,G__G_BaseDataClasses_544_0_3, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AnaTrueVertexB",1392,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB), -1, 0, 1, 1, 2, 0, "u 'AnaTrueVertexB' - 11 - vertex", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaTrueVertexB", 1518, G__G_BaseDataClasses_544_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_544_0_6, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB), -1, 1, 1, 1, 1, 0, "u 'AnaTrueVertexB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaToF(void) {
   /* AnaToF */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF));
   G__memfunc_setup("AnaToF",537,G__G_BaseDataClasses_552_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__G_BaseDataClasses_552_0_2, 117, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF), -1, 1, 1, 1, 1, 0, "u 'AnaToF' - 11 - B", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__G_BaseDataClasses_552_0_3, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("AnaToF", 537, G__G_BaseDataClasses_552_0_4, (int) ('i'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaToF), -1, 0, 1, 1, 1, 0, "u 'AnaToF' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaToF", 663, G__G_BaseDataClasses_552_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaParticleB(void) {
   /* AnaParticleB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB));
   G__memfunc_setup("AnaParticleB",1158,G__G_BaseDataClasses_554_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CompareNHits",1197,G__G_BaseDataClasses_554_0_4, 103, -1, -1, 0, 2, 3, 1, 0, 
"U 'AnaRecObjectC' - 10 - p1 U 'AnaRecObjectC' - 10 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const AnaRecObjectC*, const AnaRecObjectC*))(&AnaParticleB::CompareNHits) ), 0);
   G__memfunc_setup("GetTrueParticle",1524,G__G_BaseDataClasses_554_0_5, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AnaParticleB",1158,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB), -1, 0, 1, 1, 2, 0, "u 'AnaParticleB' - 11 - part", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaParticleB", 1284, G__G_BaseDataClasses_554_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaParticleMomE(void) {
   /* AnaParticleMomE */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE));
   G__memfunc_setup("AnaParticleMomE",1458,G__G_BaseDataClasses_555_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__G_BaseDataClasses_555_0_2, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaParticleMomE",1458,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE), -1, 0, 1, 1, 2, 0, "u 'AnaParticleMomE' - 11 - part", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaParticleMomE", 1584, G__G_BaseDataClasses_555_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_555_0_5, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomE), -1, 1, 1, 1, 1, 0, "u 'AnaParticleMomE' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaParticleMomB(void) {
   /* AnaParticleMomB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB));
   G__memfunc_setup("AnaParticleMomB",1455,G__G_BaseDataClasses_556_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CompareMomentum",1561,G__G_BaseDataClasses_556_0_4, 103, -1, -1, 0, 2, 3, 1, 0, 
"U 'AnaRecObjectC' - 10 - p1 U 'AnaRecObjectC' - 10 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const AnaRecObjectC*, const AnaRecObjectC*))(&AnaParticleMomB::CompareMomentum) ), 0);
   G__memfunc_setup("AnaParticleMomB",1455,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleMomB), -1, 0, 1, 1, 2, 0, "u 'AnaParticleMomB' - 11 - part", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaParticleMomB", 1581, G__G_BaseDataClasses_556_0_6, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaTPCParticleB(void) {
   /* AnaTPCParticleB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB));
   G__memfunc_setup("AnaTPCParticleB",1389,G__G_BaseDataClasses_557_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaTPCParticleB",1389,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTPCParticleB), -1, 0, 1, 1, 2, 0, "u 'AnaTPCParticleB' - 11 - seg", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaTPCParticleB", 1515, G__G_BaseDataClasses_557_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaFGDParticleB(void) {
   /* AnaFGDParticleB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB));
   G__memfunc_setup("AnaFGDParticleB",1367,G__G_BaseDataClasses_558_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaFGDParticleB",1367,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFGDParticleB), -1, 0, 1, 1, 2, 0, "u 'AnaFGDParticleB' - 11 - seg", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaFGDParticleB", 1493, G__G_BaseDataClasses_558_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaECALParticleB(void) {
   /* AnaECALParticleB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB));
   G__memfunc_setup("AnaECALParticleB",1435,G__G_BaseDataClasses_559_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaECALParticleB",1435,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaECALParticleB), -1, 0, 1, 1, 2, 0, "u 'AnaECALParticleB' - 11 - seg", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaECALParticleB", 1561, G__G_BaseDataClasses_559_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaSMRDParticleB(void) {
   /* AnaSMRDParticleB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB));
   G__memfunc_setup("AnaSMRDParticleB",1468,G__G_BaseDataClasses_560_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaSMRDParticleB",1468,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSMRDParticleB), -1, 0, 1, 1, 2, 0, "u 'AnaSMRDParticleB' - 11 - seg", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaSMRDParticleB", 1594, G__G_BaseDataClasses_560_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaP0DParticleB(void) {
   /* AnaP0DParticleB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB));
   G__memfunc_setup("AnaP0DParticleB",1354,G__G_BaseDataClasses_561_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaP0DParticleB",1354,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaP0DParticleB), -1, 0, 1, 1, 2, 0, "u 'AnaP0DParticleB' - 11 - seg", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaP0DParticleB", 1480, G__G_BaseDataClasses_561_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaTrackerTrackB(void) {
   /* AnaTrackerTrackB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB));
   G__memfunc_setup("AnaTrackerTrackB",1555,G__G_BaseDataClasses_562_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaTrackerTrackB",1555,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackerTrackB), -1, 0, 1, 1, 2, 0, "u 'AnaTrackerTrackB' - 11 - seg", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaTrackerTrackB", 1681, G__G_BaseDataClasses_562_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaRecTrueMatchB(void) {
   /* AnaRecTrueMatchB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB));
   G__memfunc_setup("AnaRecTrueMatchB",1529,G__G_BaseDataClasses_563_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,G__G_BaseDataClasses_563_0_2, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("AnaRecTrueMatchB", 1529, G__G_BaseDataClasses_563_0_3, (int) ('i'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB), -1, 0, 1, 1, 1, 0, "u 'AnaRecTrueMatchB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaRecTrueMatchB", 1655, G__G_BaseDataClasses_563_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_563_0_5, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaRecTrueMatchB), -1, 1, 1, 1, 1, 0, "u 'AnaRecTrueMatchB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaTrackB(void) {
   /* AnaTrackB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB));
   G__memfunc_setup("AnaTrackB",839,G__G_BaseDataClasses_564_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetOriginalTrack",1610,G__G_BaseDataClasses_564_0_4, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CompareMuonRangeMomentum",2469,G__G_BaseDataClasses_564_0_5, 103, -1, -1, 0, 2, 3, 1, 0, 
"U 'AnaRecObjectC' - 10 - p1 U 'AnaRecObjectC' - 10 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const AnaRecObjectC*, const AnaRecObjectC*))(&AnaTrackB::CompareMuonRangeMomentum) ), 0);
   G__memfunc_setup("CompareProtonRangeMomentum",2696,G__G_BaseDataClasses_564_0_6, 103, -1, -1, 0, 2, 3, 1, 0, 
"U 'AnaRecObjectC' - 10 - p1 U 'AnaRecObjectC' - 10 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const AnaRecObjectC*, const AnaRecObjectC*))(&AnaTrackB::CompareProtonRangeMomentum) ), 0);
   G__memfunc_setup("ComparePionRangeMomentum",2460,G__G_BaseDataClasses_564_0_7, 103, -1, -1, 0, 2, 3, 1, 0, 
"U 'AnaRecObjectC' - 10 - p1 U 'AnaRecObjectC' - 10 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const AnaRecObjectC*, const AnaRecObjectC*))(&AnaTrackB::ComparePionRangeMomentum) ), 0);
   G__memfunc_setup("Flip",395,G__G_BaseDataClasses_564_0_8, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("UnFlip",590,G__G_BaseDataClasses_564_0_9, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetIsFlipped",1184,G__G_BaseDataClasses_564_0_10, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AnaTrackB",839,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrackB), -1, 0, 1, 1, 2, 0, "u 'AnaTrackB' - 11 - track", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaTrackB", 965, G__G_BaseDataClasses_564_0_12, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaVertexB(void) {
   /* AnaVertexB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB));
   G__memfunc_setup("AnaVertexB",976,G__G_BaseDataClasses_585_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,G__G_BaseDataClasses_585_0_3, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ComparePrimaryIndex",1955,G__G_BaseDataClasses_585_0_4, 103, -1, -1, 0, 2, 3, 1, 0, 
"U 'AnaRecObjectC' - 10 - p1 U 'AnaRecObjectC' - 10 - p2", (char*)NULL, (void*) G__func2void( (bool (*)(const AnaRecObjectC*, const AnaRecObjectC*))(&AnaVertexB::ComparePrimaryIndex) ), 0);
   G__memfunc_setup("AnaVertexB",976,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB), -1, 0, 1, 1, 2, 0, "u 'AnaVertexB' - 11 - vertex", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTrueVertices",1541,G__G_BaseDataClasses_585_0_6, 105, -1, -1, 0, 1, 1, 1, 0, "U 'AnaTrueVertexB' - 2 - arr", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMainTrueVertex",1731,G__G_BaseDataClasses_585_0_7, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB), -1, 0, 1, 1, 1, 0, "g - - 0 'true' warning", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMainTrueVertexCleanliness",2868,G__G_BaseDataClasses_585_0_8, 102, -1, G__defined_typename("Float_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetMainTrueVertexCompleteness",2997,G__G_BaseDataClasses_585_0_9, 102, -1, G__defined_typename("Float_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTrueVertexCleanliness",2479,G__G_BaseDataClasses_585_0_10, 102, -1, G__defined_typename("Float_t"), 0, 1, 1, 1, 0, "u 'AnaTrueVertexB' - 11 - trueVertex", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTrueVertexCompleteness",2608,G__G_BaseDataClasses_585_0_11, 102, -1, G__defined_typename("Float_t"), 0, 1, 1, 1, 0, "u 'AnaTrueVertexB' - 11 - trueVertex", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaVertexB", 1102, G__G_BaseDataClasses_585_0_12, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaBeamB(void) {
   /* AnaBeamB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB));
   G__memfunc_setup("AnaBeamB",711,G__G_BaseDataClasses_591_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,G__G_BaseDataClasses_591_0_2, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaBeamB",711,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB), -1, 0, 1, 1, 2, 0, "u 'AnaBeamB' - 11 - beam", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaBeamB", 837, G__G_BaseDataClasses_591_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_591_0_5, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBeamB), -1, 1, 1, 1, 1, 0, "u 'AnaBeamB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaDataQualityB(void) {
   /* AnaDataQualityB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB));
   G__memfunc_setup("AnaDataQualityB",1461,G__G_BaseDataClasses_592_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,G__G_BaseDataClasses_592_0_2, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaDataQualityB",1461,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB), -1, 0, 1, 1, 2, 0, "u 'AnaDataQualityB' - 11 - dq", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaDataQualityB", 1587, G__G_BaseDataClasses_592_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_592_0_5, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDataQualityB), -1, 1, 1, 1, 1, 0, "u 'AnaDataQualityB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaDelayedClustersB(void) {
   /* AnaDelayedClustersB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB));
   G__memfunc_setup("AnaDelayedClustersB",1887,G__G_BaseDataClasses_593_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,G__G_BaseDataClasses_593_0_2, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaDelayedClustersB",1887,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB), -1, 0, 1, 1, 2, 0, "u 'AnaDelayedClustersB' - 11 - clusters", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaDelayedClustersB", 2013, G__G_BaseDataClasses_593_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_593_0_5, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaDelayedClustersB), -1, 1, 1, 1, 1, 0, "u 'AnaDelayedClustersB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaBunchB(void) {
   /* AnaBunchB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB));
   G__memfunc_setup("AnaBunchB",834,G__G_BaseDataClasses_594_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetPrimaryVertex",1666,G__G_BaseDataClasses_594_0_4, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaVertexB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("IsEmpty",715,G__G_BaseDataClasses_594_0_5, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaBunchB",834,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB), -1, 0, 1, 1, 2, 0, "u 'AnaBunchB' - 11 - bunch", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaBunchB", 960, G__G_BaseDataClasses_594_0_7, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_594_0_8, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaBunchB), -1, 1, 1, 1, 1, 0, "u 'AnaBunchB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaFgdTimeBinB(void) {
   /* AnaFgdTimeBinB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB));
   G__memfunc_setup("AnaFgdTimeBinB",1291,G__G_BaseDataClasses_603_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,G__G_BaseDataClasses_603_0_2, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,G__G_BaseDataClasses_603_0_3, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaFgdTimeBinB",1291,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB), -1, 0, 1, 1, 2, 0, "u 'AnaFgdTimeBinB' - 11 - timeBin", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaFgdTimeBinB", 1417, G__G_BaseDataClasses_603_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_603_0_6, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaFgdTimeBinB), -1, 1, 1, 1, 1, 0, "u 'AnaFgdTimeBinB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaEventInfoB(void) {
   /* AnaEventInfoB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB));
   G__memfunc_setup("AnaEventInfoB",1248,G__G_BaseDataClasses_604_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,G__G_BaseDataClasses_604_0_2, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,G__G_BaseDataClasses_604_0_3, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetIsMC",620,G__G_BaseDataClasses_604_0_4, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetIsSandMC",1010,G__G_BaseDataClasses_604_0_5, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetIsSandMC",1022,G__G_BaseDataClasses_604_0_6, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AnaEventInfoB",1248,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB), -1, 0, 1, 1, 2, 0, "u 'AnaEventInfoB' - 11 - event", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaEventInfoB", 1374, G__G_BaseDataClasses_604_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_604_0_9, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventInfoB), -1, 1, 1, 1, 1, 0, "u 'AnaEventInfoB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaSpillB(void) {
   /* AnaSpillB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB));
   G__memfunc_setup("AnaSpillB",854,G__G_BaseDataClasses_605_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetIsMC",620,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetIsSandMC",1010,G__G_BaseDataClasses_605_0_5, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("CopyArraysIntoVectors",2189,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("CopyVectorsIntoArrays",2189,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("RedoLinks",907,(G__InterfaceMethod) NULL,121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 'false' full", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetTrueParticleByID",1852,G__G_BaseDataClasses_605_0_9, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueParticleB), -1, 0, 1, 1, 1, 0, "i - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetTrueVertexByID",1670,G__G_BaseDataClasses_605_0_10, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaTrueVertexB), -1, 0, 1, 1, 1, 0, "i - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetParticleByUniqueID",2067,G__G_BaseDataClasses_605_0_11, 85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaParticleB), -1, 0, 1, 1, 1, 0, "i - - 0 - ID", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AnaSpillB",854,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB), -1, 0, 1, 1, 2, 0, "u 'AnaSpillB' - 11 - spill", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("associateTrueObjectToParticle",2986,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 0, "U 'AnaRecObjectC' - 0 - recoObject", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("associateVertexToParticle",2609,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 2, 1, 2, 8, 
"U 'AnaParticleB' - 0 - - U 'AnaVertexB' - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("associateVertexToTrueVertex",2843,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 8, "U 'AnaVertexB' - 0 - -", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("associateParticleToTrueParticle",3207,(G__InterfaceMethod) NULL, 121, -1, -1, 0, 1, 1, 2, 8, "U 'AnaParticleB' - 0 - -", (char*)NULL, (void*) NULL, 1);
   // automatic destructor
   G__memfunc_setup("~AnaSpillB", 980, G__G_BaseDataClasses_605_0_17, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_605_0_18, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaSpillB), -1, 1, 1, 1, 1, 0, "u 'AnaSpillB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncAnaEventB(void) {
   /* AnaEventB */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB));
   G__memfunc_setup("AnaEventB",852,G__G_BaseDataClasses_619_0_1, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("AnaEventB",852,G__G_BaseDataClasses_619_0_2, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB), -1, 0, 2, 1, 1, 0, 
"u 'AnaSpillB' - 11 - spill u 'AnaBunchB' - 11 - bunch", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Copy",411,(G__InterfaceMethod) NULL,121, -1, -1, 0, 3, 1, 1, 0, 
"u 'AnaEventC' - 11 - event g - - 0 'true' copyBunchInfo "
"g - - 0 'true' cloneTruth", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Clone",497,(G__InterfaceMethod) NULL,85, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("Print",525,(G__InterfaceMethod) NULL,121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetIsMC",620,(G__InterfaceMethod) NULL,103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("GetIsSandMC",1010,G__G_BaseDataClasses_619_0_7, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetEventInfoString",1829,(G__InterfaceMethod) NULL,117, G__get_linked_tagnum(&G__G_BaseDataClassesLN_string), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("AnaEventB",852,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB), -1, 0, 1, 1, 2, 0, "u 'AnaEventB' - 11 - event", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~AnaEventB", 978, G__G_BaseDataClasses_619_0_10, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__G_BaseDataClasses_619_0_11, (int) ('u'), G__get_linked_tagnum(&G__G_BaseDataClassesLN_AnaEventB), -1, 1, 1, 1, 1, 0, "u 'AnaEventB' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncG_BaseDataClasses() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalG_BaseDataClasses() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
}

static void G__cpp_setup_func21() {
}

static void G__cpp_setup_func22() {
}

static void G__cpp_setup_func23() {
}

static void G__cpp_setup_func24() {
}

static void G__cpp_setup_func25() {
}

static void G__cpp_setup_func26() {
}

static void G__cpp_setup_func27() {
}

static void G__cpp_setup_func28() {
}

static void G__cpp_setup_func29() {
}

static void G__cpp_setup_func30() {
}

static void G__cpp_setup_func31() {
}

static void G__cpp_setup_func32() {
}

static void G__cpp_setup_func33() {
}

static void G__cpp_setup_func34() {
}

static void G__cpp_setup_func35() {
}

static void G__cpp_setup_func36() {
}

static void G__cpp_setup_func37() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcG_BaseDataClasses() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
  G__cpp_setup_func21();
  G__cpp_setup_func22();
  G__cpp_setup_func23();
  G__cpp_setup_func24();
  G__cpp_setup_func25();
  G__cpp_setup_func26();
  G__cpp_setup_func27();
  G__cpp_setup_func28();
  G__cpp_setup_func29();
  G__cpp_setup_func30();
  G__cpp_setup_func31();
  G__cpp_setup_func32();
  G__cpp_setup_func33();
  G__cpp_setup_func34();
  G__cpp_setup_func35();
  G__cpp_setup_func36();
  G__cpp_setup_func37();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__G_BaseDataClassesLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTBaselEfloatgR = { "TMatrixTBase<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTBaselEdoublegR = { "TMatrixTBase<double>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TVectorTlEfloatgR = { "TVectorT<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TVectorTlEdoublegR = { "TVectorT<double>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TElementActionTlEfloatgR = { "TElementActionT<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TElementPosActionTlEfloatgR = { "TElementPosActionT<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTlEfloatgR = { "TMatrixT<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTRow_constlEfloatgR = { "TMatrixTRow_const<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTRowlEfloatgR = { "TMatrixTRow<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTDiag_constlEfloatgR = { "TMatrixTDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTColumn_constlEfloatgR = { "TMatrixTColumn_const<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTFlat_constlEfloatgR = { "TMatrixTFlat_const<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTSub_constlEfloatgR = { "TMatrixTSub_const<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTSparseRow_constlEfloatgR = { "TMatrixTSparseRow_const<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTSparseDiag_constlEfloatgR = { "TMatrixTSparseDiag_const<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTColumnlEfloatgR = { "TMatrixTColumn<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTDiaglEfloatgR = { "TMatrixTDiag<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTFlatlEfloatgR = { "TMatrixTFlat<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTSublEfloatgR = { "TMatrixTSub<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTSparseRowlEfloatgR = { "TMatrixTSparseRow<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_TMatrixTSparseDiaglEfloatgR = { "TMatrixTSparseDiag<float>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaTrueObjectC = { "AnaTrueObjectC" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaRecObjectC = { "AnaRecObjectC" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaBunchC = { "AnaBunchC" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaSpillC = { "AnaSpillC" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgR = { "vector<AnaBunchC*,allocator<AnaBunchC*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaBunchC*,allocator<AnaBunchC*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaEventC = { "AnaEventC" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_setlEstringcOlesslEstringgRcOallocatorlEstringgRsPgR = { "set<string,less<string>,allocator<string> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_maplEstringcOSampleIdcLcLSampleEnumcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOSampleIdcLcLSampleEnumgRsPgRsPgR = { "map<string,SampleId::SampleEnum,less<string>,allocator<pair<const string,SampleId::SampleEnum> > >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaTrueParticleB = { "AnaTrueParticleB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaDetCrossingB = { "AnaDetCrossingB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaTrueVertexB = { "AnaTrueVertexB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<int,allocator<int> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgR = { "vector<AnaDetCrossingB*,allocator<AnaDetCrossingB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaDetCrossingB*,allocator<AnaDetCrossingB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaToF = { "AnaToF" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag = { "AnaToF::TimeStatusFlag" , 101 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaParticleB = { "AnaParticleB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaParticleMomE = { "AnaParticleMomE" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaParticleMomB = { "AnaParticleMomB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaTPCParticleB = { "AnaTPCParticleB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaFGDParticleB = { "AnaFGDParticleB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaECALParticleB = { "AnaECALParticleB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaSMRDParticleB = { "AnaSMRDParticleB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaP0DParticleB = { "AnaP0DParticleB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaTrackerTrackB = { "AnaTrackerTrackB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaRecTrueMatchB = { "AnaRecTrueMatchB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaTrackB = { "AnaTrackB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgR = { "vector<AnaTPCParticleB*,allocator<AnaTPCParticleB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaTPCParticleB*,allocator<AnaTPCParticleB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgR = { "vector<AnaFGDParticleB*,allocator<AnaFGDParticleB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaFGDParticleB*,allocator<AnaFGDParticleB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgR = { "vector<AnaECALParticleB*,allocator<AnaECALParticleB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaECALParticleB*,allocator<AnaECALParticleB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgR = { "vector<AnaSMRDParticleB*,allocator<AnaSMRDParticleB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaSMRDParticleB*,allocator<AnaSMRDParticleB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgR = { "vector<AnaP0DParticleB*,allocator<AnaP0DParticleB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaP0DParticleB*,allocator<AnaP0DParticleB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaVertexB = { "AnaVertexB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR = { "vector<pair<AnaTrueVertexB*,AnaRecTrueMatchB>,allocator<pair<AnaTrueVertexB*,AnaRecTrueMatchB> > >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<pair<AnaTrueVertexB*,AnaRecTrueMatchB>,allocator<pair<AnaTrueVertexB*,AnaRecTrueMatchB> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaBeamB = { "AnaBeamB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaDataQualityB = { "AnaDataQualityB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaDelayedClustersB = { "AnaDelayedClustersB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaBunchB = { "AnaBunchB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgR = { "vector<AnaVertexB*,allocator<AnaVertexB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaVertexB*,allocator<AnaVertexB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgR = { "vector<AnaParticleB*,allocator<AnaParticleB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaParticleB*,allocator<AnaParticleB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaFgdTimeBinB = { "AnaFgdTimeBinB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaEventInfoB = { "AnaEventInfoB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaSpillB = { "AnaSpillB" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgR = { "vector<AnaTrueVertexB*,allocator<AnaTrueVertexB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaTrueVertexB*,allocator<AnaTrueVertexB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgR = { "vector<AnaTrueParticleB*,allocator<AnaTrueParticleB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaTrueParticleB*,allocator<AnaTrueParticleB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_vectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgR = { "vector<AnaFgdTimeBinB*,allocator<AnaFgdTimeBinB*> >" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<AnaFgdTimeBinB*,allocator<AnaFgdTimeBinB*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__G_BaseDataClassesLN_AnaEventB = { "AnaEventB" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableG_BaseDataClasses() {
  G__G_BaseDataClassesLN_string.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTBaselEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTBaselEdoublegR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TVectorTlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TVectorTlEdoublegR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TElementActionTlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TElementPosActionTlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTRow_constlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTRowlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTDiag_constlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTColumn_constlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTFlat_constlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTSub_constlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTSparseRow_constlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTSparseDiag_constlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTColumnlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTDiaglEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTFlatlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTSublEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTSparseRowlEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_TMatrixTSparseDiaglEfloatgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaTrueObjectC.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaRecObjectC.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaBunchC.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaSpillC.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaEventC.tagnum = -1 ;
  G__G_BaseDataClassesLN_setlEstringcOlesslEstringgRcOallocatorlEstringgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_maplEstringcOSampleIdcLcLSampleEnumcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOSampleIdcLcLSampleEnumgRsPgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaTrueParticleB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaDetCrossingB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaTrueVertexB.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaToF.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaParticleB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaParticleMomE.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaParticleMomB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaTPCParticleB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaFGDParticleB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaECALParticleB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaSMRDParticleB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaP0DParticleB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaTrackerTrackB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaRecTrueMatchB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaTrackB.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaVertexB.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaBeamB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaDataQualityB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaDelayedClustersB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaBunchB.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaFgdTimeBinB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaEventInfoB.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaSpillB.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_vectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__G_BaseDataClassesLN_AnaEventB.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableG_BaseDataClasses() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_string);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTBaselEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTBaselEdoublegR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TVectorTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TVectorTlEdoublegR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TElementActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TElementPosActionTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTColumn_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTFlat_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTSub_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTSparseRow_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTSparseDiag_constlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTColumnlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTDiaglEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTFlatlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTSublEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTSparseRowlEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_TMatrixTSparseDiaglEfloatgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaTrueObjectC);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaRecObjectC);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaBunchC);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaSpillC);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaBunchCmUcOallocatorlEAnaBunchCmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaEventC);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_setlEstringcOlesslEstringgRcOallocatorlEstringgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_maplEstringcOSampleIdcLcLSampleEnumcOlesslEstringgRcOallocatorlEpairlEconstsPstringcOSampleIdcLcLSampleEnumgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaTrueParticleB),sizeof(AnaTrueParticleB),-1,263936,(char*)NULL,G__setup_memvarAnaTrueParticleB,G__setup_memfuncAnaTrueParticleB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaDetCrossingB),sizeof(AnaDetCrossingB),-1,263936,(char*)NULL,G__setup_memvarAnaDetCrossingB,G__setup_memfuncAnaDetCrossingB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaTrueVertexB),sizeof(AnaTrueVertexB),-1,263936,(char*)NULL,G__setup_memvarAnaTrueVertexB,G__setup_memfuncAnaTrueVertexB);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEintcOallocatorlEintgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEintcOallocatorlEintgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaDetCrossingBmUcOallocatorlEAnaDetCrossingBmUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaToF),sizeof(AnaToF),-1,264448,(char*)NULL,G__setup_memvarAnaToF,G__setup_memfuncAnaToF);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaToFcLcLTimeStatusFlag);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaParticleB),sizeof(AnaParticleB),-1,263936,(char*)NULL,G__setup_memvarAnaParticleB,G__setup_memfuncAnaParticleB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaParticleMomE),sizeof(AnaParticleMomE),-1,263936,(char*)NULL,G__setup_memvarAnaParticleMomE,G__setup_memfuncAnaParticleMomE);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaParticleMomB),sizeof(AnaParticleMomB),-1,263936,(char*)NULL,G__setup_memvarAnaParticleMomB,G__setup_memfuncAnaParticleMomB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaTPCParticleB),sizeof(AnaTPCParticleB),-1,263936,(char*)NULL,G__setup_memvarAnaTPCParticleB,G__setup_memfuncAnaTPCParticleB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaFGDParticleB),sizeof(AnaFGDParticleB),-1,263936,(char*)NULL,G__setup_memvarAnaFGDParticleB,G__setup_memfuncAnaFGDParticleB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaECALParticleB),sizeof(AnaECALParticleB),-1,263936,(char*)NULL,G__setup_memvarAnaECALParticleB,G__setup_memfuncAnaECALParticleB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaSMRDParticleB),sizeof(AnaSMRDParticleB),-1,263936,(char*)NULL,G__setup_memvarAnaSMRDParticleB,G__setup_memfuncAnaSMRDParticleB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaP0DParticleB),sizeof(AnaP0DParticleB),-1,263936,(char*)NULL,G__setup_memvarAnaP0DParticleB,G__setup_memfuncAnaP0DParticleB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaTrackerTrackB),sizeof(AnaTrackerTrackB),-1,263936,(char*)NULL,G__setup_memvarAnaTrackerTrackB,G__setup_memfuncAnaTrackerTrackB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaRecTrueMatchB),sizeof(AnaRecTrueMatchB),-1,263424,(char*)NULL,G__setup_memvarAnaRecTrueMatchB,G__setup_memfuncAnaRecTrueMatchB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaTrackB),sizeof(AnaTrackB),-1,263936,(char*)NULL,G__setup_memvarAnaTrackB,G__setup_memfuncAnaTrackB);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTPCParticleBmUcOallocatorlEAnaTPCParticleBmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFGDParticleBmUcOallocatorlEAnaFGDParticleBmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaECALParticleBmUcOallocatorlEAnaECALParticleBmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaSMRDParticleBmUcOallocatorlEAnaSMRDParticleBmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaP0DParticleBmUcOallocatorlEAnaP0DParticleBmUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaVertexB),sizeof(AnaVertexB),-1,263936,(char*)NULL,G__setup_memvarAnaVertexB,G__setup_memfuncAnaVertexB);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRcOallocatorlEpairlEAnaTrueVertexBmUcOAnaRecTrueMatchBgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaBeamB),sizeof(AnaBeamB),-1,263936,(char*)NULL,G__setup_memvarAnaBeamB,G__setup_memfuncAnaBeamB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaDataQualityB),sizeof(AnaDataQualityB),-1,263936,(char*)NULL,G__setup_memvarAnaDataQualityB,G__setup_memfuncAnaDataQualityB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaDelayedClustersB),sizeof(AnaDelayedClustersB),-1,263936,(char*)NULL,G__setup_memvarAnaDelayedClustersB,G__setup_memfuncAnaDelayedClustersB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaBunchB),sizeof(AnaBunchB),-1,263936,(char*)NULL,G__setup_memvarAnaBunchB,G__setup_memfuncAnaBunchB);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaVertexBmUcOallocatorlEAnaVertexBmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaParticleBmUcOallocatorlEAnaParticleBmUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaFgdTimeBinB),sizeof(AnaFgdTimeBinB),-1,263936,(char*)NULL,G__setup_memvarAnaFgdTimeBinB,G__setup_memfuncAnaFgdTimeBinB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaEventInfoB),sizeof(AnaEventInfoB),-1,263936,(char*)NULL,G__setup_memvarAnaEventInfoB,G__setup_memfuncAnaEventInfoB);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaSpillB),sizeof(AnaSpillB),-1,263936,(char*)NULL,G__setup_memvarAnaSpillB,G__setup_memfuncAnaSpillB);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueVertexBmUcOallocatorlEAnaTrueVertexBmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaTrueParticleBmUcOallocatorlEAnaTrueParticleBmUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_vectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgR);
   G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_reverse_iteratorlEvectorlEAnaFgdTimeBinBmUcOallocatorlEAnaFgdTimeBinBmUgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__G_BaseDataClassesLN_AnaEventB),sizeof(AnaEventB),-1,296704,(char*)NULL,G__setup_memvarAnaEventB,G__setup_memfuncAnaEventB);
}
extern "C" void G__cpp_setupG_BaseDataClasses(void) {
  G__check_setup_version(30051515,"G__cpp_setupG_BaseDataClasses()");
  G__set_cpp_environmentG_BaseDataClasses();
  G__cpp_setup_tagtableG_BaseDataClasses();

  G__cpp_setup_inheritanceG_BaseDataClasses();

  G__cpp_setup_typetableG_BaseDataClasses();

  G__cpp_setup_memvarG_BaseDataClasses();

  G__cpp_setup_memfuncG_BaseDataClasses();
  G__cpp_setup_globalG_BaseDataClasses();
  G__cpp_setup_funcG_BaseDataClasses();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncG_BaseDataClasses();
  return;
}
class G__cpp_setup_initG_BaseDataClasses {
  public:
    G__cpp_setup_initG_BaseDataClasses() { G__add_setup_func("G_BaseDataClasses",(G__incsetup)(&G__cpp_setupG_BaseDataClasses)); G__call_setup_funcs(); }
   ~G__cpp_setup_initG_BaseDataClasses() { G__remove_setup_func("G_BaseDataClasses"); }
};
G__cpp_setup_initG_BaseDataClasses G__cpp_setup_initializerG_BaseDataClasses;

